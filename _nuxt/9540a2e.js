(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{303:function(o,e,n){var map={"./2021/create-blog-github.md":309,"./2021/webpack-pack-path.md":310,"./2022/about-prototype.md":311,"./2022/build-webpack5-feeling.md":312,"./2022/js-inherit.md":313,"./2022/let-miniprogram-use-less.md":314};function c(o){var e=t(o);return n(e)}function t(o){if(!n.o(map,o)){var e=new Error("Cannot find module '"+o+"'");throw e.code="MODULE_NOT_FOUND",e}return map[o]}c.keys=function(){return Object.keys(map)},c.resolve=t,o.exports=c,c.id=303},309:function(o,e){o.exports={attributes:{title:"如何使用nuxtJs在github.io搭建自己博客",des:"让你DIY专属于自己的博客",createTime:"2021-6-2"},html:'<h1>如何使用<code>nuxtJs</code>在<code>github.io</code>搭建自己博客</h1>\n<blockquote>\n<p>可以使用<code>nuxtJS</code> <code>DIY</code>一个专属自己的博客，利用 <code>markdown</code> 来记录博客</p>\n</blockquote>\n<h2>概述</h2>\n<ol>\n<li>设置 <code>github</code> 上的个人主页</li>\n<li>在本地构建项目</li>\n<li>部署踩坑</li>\n</ol>\n<blockquote>\n<h3>设置 <code>github</code> 上的个人主页</h3>\n</blockquote>\n<ol>\n<li>\n<p>新建一个项目<br>\n登录<code>github</code>以后，点击主页的 <code>New</code> 按钮新建一个代表个人主页的仓库\n<img src="../md/create-blog-github/step_1.png" alt="">\n仓库名字自取，可以取<code>姓名全拼</code> + <code>github.io</code>，博主的个人主页仓库名叫就是：<code>limingcan562.github.io</code></p>\n</li>\n<li>\n<p>完成以后回到主页你会发现仓库多了一个叫 <code>limingcan562.github.io</code> 的仓库（<em>请取你自己的名字</em>），进入以后点击 <code>Settings</code>\n<img src="../md/create-blog-github/step_3.png" alt=""></p>\n</li>\n<li>\n<p>设置未来 <code>github.io</code> 主页的链接<br>\n进入到自己刚刚建好的仓库进行配置\n<img src="../md/create-blog-github/step_2.png" alt=""></p>\n<p><strong>注意：</strong></p>\n<ul>\n<li><code>Repository name</code> 请填写前面的 <code>Owner</code> 名字 + <code>.github.io</code></li>\n<li>如图示，<code>Repository name</code> 就应该写 <code>limingcan562.github.io</code> 这样后面可以直接用 <code>limingcan562.github.io</code> 打开你的个人主页</li>\n</ul>\n</li>\n<li>\n<p>修改个人主页映射对应的仓库分支\n<img src="../md/create-blog-github/step_4.png" alt=""></p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>我是将打包好的文件推送到仓库的<code>gh-pages</code>分支，所以需要把个人主页映射到<code>gh-pages</code>分支，这样当你打开个人主页是，其实看到的是编译好的<code>gh-pages</code>分支内容</li>\n<li>推送 <code>gh-pages</code> 也是个坑，后续会讲</li>\n</ul>\n</li>\n<li>\n<p>OK，目前我们<code>github</code>部分就完成了</p>\n</li>\n</ol>\n<blockquote>\n<h3>在本地构建项目</h3>\n</blockquote>\n<p>这个就不过多的赘述了，因为我的博客是用<code>nuxtJs</code>做的，所以直接上官网看看文档，直接搞个<code>demo</code>项目下来，这里主要介绍下我用到的插件文档</p>\n<ul>\n<li><a href="https://www.nuxtjs.cn/"><code>nuxtJs</code></a></li>\n<li><a href="https://www.npmjs.com/package/"><code>frontmatter-markdown-loader</code></a>用来编译<code>md</code>的<code>loader</code></li>\n<li><a href="https://www.npmjs.com/package/github-markdown-css"><code>github-markdown-css</code></a> 美化编译后的<code>md</code></li>\n<li><a href="https://www.npmjs.com/package/prismjs"><code>prismjs</code></a> 用来高亮<code>md</code></li>\n<li><a href="https://www.npmjs.com/package/gh-pages"><code>gh-pages</code></a> 用来发布打包文件到<code>github</code>的<code>gh-pages</code>分支</li>\n</ul>\n<blockquote>\n<h3>部署踩坑</h3>\n</blockquote>\n<ol>\n<li>用<code>soureceTree</code>一直推不上<code>github</code>或者拉不下代码，等了好久以后报错问题！</li>\n<li>使用<code>gh-pages</code>推送分支部署时，老是报错！</li>\n<li>代码推到<code>gh-pages</code> 分支后，为什么不能预览，资源<code>404</code>！</li>\n</ol>\n<ul>\n<li>\n<h4>用<code>soureceTree</code>一直推不上<code>github</code>或者拉不下代码，等了好久以后报错问题！</h4>\n</li>\n</ul>\n<p>不知道用<code>soureceTree</code>的同学有没有遇到过，在拉<code>github</code>代码或者推代码到<code>github</code>时，发现等了很久，结果后面发现各种各样的报错，或者一直弹出要输入github账号密码，就十分的烦躁...但后面上网各种找答案以后，终于有办法可以解决：<br>\n<strong>不要用<code>https</code>的方式连接<code>github</code>仓库，一定要用<code>ssh</code>方式连接仓库</strong></p>\n<p><code>mac</code>端跟着网上配置<code>ssh</code>到<code>github</code>的步骤走，问题不大，但是在生成<code>ssh</code>时，会提示要你输入密码，此时不要输入密码，一路回车就好了，这样后面推送代码的时候，就不会再提示输入密码。这里讲下<code>window</code>环境下怎么弄<br>\n在配置好<code>ssh</code>到<code>github</code>以后，我们会发现<code>window</code>的<code>souceTree</code>拉取代码还是有问题，这里需要设置一下：<br>\n进入<code>工具</code> --&gt; <code>选项</code>\n<img src="../md/create-blog-github/step_5.png" alt="">\n这样设置好以后，关掉<code>sourceTree</code>重新推一下就好了</p>\n<ul>\n<li>\n<h4>使用<code>gh-pages</code>推送分支部署时，老是报错！</h4>\n</li>\n</ul>\n<p>有时我们可能使用<code>gh-pages</code>推送分支，或者把远程<code>gh-pages</code>删除在推送，或者做了什么乱七八糟的操作以后，发现经常报错，类似：</p>\n<pre><code class="language-javascript">{&quot;code&quot;:128,&quot;message&quot;:&quot;fatal: couldn\'t find remote ref refs/heads/gh-pages\\n&quot;,&quot;name&quot;:&quot;ProcessError&quot;}\n</code></pre>\n<p>就会十分的崩溃，但是在查阅了很多资料以后发现还是有解决方案的：</p>\n<ol>\n<li>在项目下的终端运行：<code>node node_modules/gh-pages/bin/gh-pages-clean</code>；然后再推送，你会发现问题迎刃而解！可以参考<a href="https://www.bountysource.com/teams/gh-pages/issues">这篇文章</a></li>\n<li><strong>将<code>deploy.js</code>里面的<code>repo</code>改成<code>ssh</code>链接，就好了（这个是最重要的！）</strong></li>\n</ol>\n<ul>\n<li>\n<h4>代码推到<code>gh-pages</code> 分支后，为什么不能预览，资源<code>404</code>！</h4>\n</li>\n</ul>\n<p>首先，我们使用<code>gh-pages</code>提交代码到<code>gh-pages</code>分支时，我们会看到，里面的文件都有，但是就是没有<code>.nojekyll</code>，<strong>没有<code>.nojekyll</code></strong> 是最根本的原因，默认<code>gh-pages</code>是不会把点文件推上去的\n因为如果<code>github</code>上没有这个文件，是会忽略掉其他<code>_</code>开头的文件的，因此即使<code>github</code>上有<code>_nuxt</code>文件，一样会找不到资源，因为它会被略了，具体可以参考<a href="https://www.cnblogs.com/babywhale/p/13560573.html">这篇文章</a><br>\n所以我们需要在<code>deploy.js</code>文件里改一下配置：</p>\n<pre><code class="language-javascript">ghpages.publish(\'./dist\', {\n    branch: \'gh-pages\',\n    repo: \'你的仓库ssh地址\',\n    dotfiles: true,  // 很重要！！\n    message: \'deploy\'\n}, err =&gt; {});\n</code></pre>\n<p>重点是把<code>dotfiles: true</code>，这样<code>.nojekyll</code>才能推上去</p>\n'}},310:function(o,e){o.exports={attributes:{title:"Webpack 打包时，如何保留img文件夹里原有的文件夹",des:"保留img文件夹里面原始文件，更好管理",createTime:"2021-6-21"},html:'<h2>场景</h2>\n<p>有时我们在开发模式时，会在<code>img</code>文件里建很多的不同的文件夹，方便我们开发过程中更好的管理，就像这样：<br>\n<img src="../md/webpack-pack-path/pic_1.png" alt="">\n我们把一些场景的资源用不同的文件存放，这样在我们开发的过程中，可以更快更有效地管理我们场景的资源，尤其是在做游戏项目。<br>\n当我们项目开发完了，打包时，<code>webpack</code>内部会将我们应用的图片资源，全部打包到一文件夹中，就像下面这样：\n<img src="../md/webpack-pack-path/pic_2.png" alt="">\n但是如果遇到项目上线了，只是紧急替换图片，不需要改逻辑，又或者有些奇葩客户，说打包出来图片文件不要混在一起，要分开，这样方便他们自己修改别的版本（我就遇到过），这就很尴尬了，光是找替换的文件都要找半天，所以这时如果我们在打包的时候，保留了原本<code>img</code>里面的文件夹，那就很舒服</p>\n<h2>实现</h2>\n<p><code>webpack</code>🐂🍺的地方不需要再说啦，现在说下怎么实现在打包的时候，保留<code>img</code>文件夹里面的文件夹，其实也不是很难<br>\n<code>webpack</code>配置：</p>\n<pre><code class="language-javascript">// webpack.config.js\n{\n    test: /\\.(png|jpg|jpeg|gif)$/,\n    use: [\n        {\n            loader: \'url-loader\',\n            options: {\n                //利用[path]路径获取文件夹名称并设置文件名\n                name: \'[path]/[name].[ext]\',\n                limit: 1, \n                //过滤掉[path]的相对路径\n                context: path.resolve(__dirname, \'../dev/assets\'),\n            }\n        }\n    ]\n},\n</code></pre>\n<p>我的开发目录结构：\n<img src="../md/webpack-pack-path/pic_3.png" alt=""></p>\n<p>打包以后的目录：\n<img src="../md/webpack-pack-path/pic_4.png" alt=""></p>\n<p>这样做可以过滤掉开发目录前面的路径：</p>\n<pre><code class="language-javascript">context: path.resolve(__dirname, \'../dev/assets\')\n</code></pre>\n<p>如果为了防止缓存，还可以在打包出来的图片文件加上<code>hash</code>：</p>\n<pre><code class="language-javascript">name: \'[path]/[name]-[hash:8].[ext]\',\n</code></pre>\n'}},311:function(o,e){o.exports={attributes:{title:"__proto__、prototype、constructor、原型链，真没那么难！教你怎么套用方法直接判断",des:"__proto__、prototype、constructor到底是什么？带你一步步搞明白",createTime:"2022-3-14"},html:'<h2><code>__proto__</code>、<code>prototype</code>、<code>constructor</code>、原型链，真没那么难！教你怎么套用方法直接判断</h2>\n<h3>前言</h3>\n<p>首先原型、原型链，算是前端进阶里面必不可少，十分重要的一块了。在面试，，这块特别绕，所以面试官很喜欢用这一块来辨别你的底层知识掌握的怎么样。用的第三方框架，库里面，很多功能模块化了，但大部分功能都继承自一个基类。既然涉及到继承，那也必不可少得先了解原型链，所以原型链确实重中之重。</p>\n<h3>为什么大家对原型，原型链子会感到“懵”跟“绕”</h3>\n<p>其本质是因为，<strong>大家都没理清楚<code>__proto__</code>、<code>prototype</code>、<code>constructor</code>三者的联系</strong>。所以很多人在看这一块知识的时候，刚开头看可能还能理解，看久了就懵了，因为代码中充斥着各种<code>x.__proto__.__proto__</code>，<code>x.__proto__.constructor.prototype</code>，<code>x.prototype.__proto__</code>等等，这当然会懵掉。所以我们要理解原型、原型链是什么，一定要先搞明白，<code>__proto__</code>、<code>prototype</code>、<code>constructor</code>这三个到底是个什么东西，再弄明白它们三个是什么联系。</p>\n<p>下面我会用比较通俗的话来解释，带着大家更好的理解原型，原型链是什么（因为为了大家更好的理解，所以有些地方可能会稍微有点不恰当，敬请见谅）。</p>\n<p>为了更好的理解，我们用以下变量作为例子跟话术：</p>\n<ul>\n<li><code>People</code>为构造函数</li>\n<li><code>person</code>为由<code>People</code>实例出来的一个对象</li>\n<li><code>Object</code>为构造所有对象的顶级基类构造函数</li>\n<li><code>Function</code>为构造所有函数的顶级基类构造函数</li>\n</ul>\n<h3><code>__proto__</code></h3>\n<p>这个属性可以通俗的理解成，<strong>所有对象都拥有的一个私有属性（函数也是一种特殊的对象，所以构造函数也会有这个属性）</strong>。所以我们会看到<code>person.__proto__</code>、<code>People.prototype.__proto__</code>、<code>People.__proto__</code>、<code>Object.__proto__</code>、<code>Function.__proto__</code>等描述。</p>\n<h3><code>prototype</code></h3>\n<p>这个属性可以通俗的理解成，<strong>专属于函数自身的一个属性（可用<code>hasOwnProperty</code>验证）</strong>，所以实例出来的对象不会有，只有<strong>函数、构造函数</strong>会有。我们通常都会把<code>构造函数.prototype</code>看做一个整体，它代表的是，这个函数的<code>prototype</code>里，所有的属性方法等（<code>People.prototype</code>代表<code>People.prototype</code>这个<strong>整体</strong>里，所有的属性与方法）。所以我们会看到<code>person.__proto__.prototype</code>、<code>People.prototype</code>、<code>Object.prototype</code>、<code>Function.prototype</code>等描述，但一定不会看到<code>实例.prototype</code>（<code>person.prototype</code>）。</p>\n<blockquote>\n<p>例外：</p>\n<ul>\n<li>箭头函数没有<code>prototype</code>，箭头函数也不能拿来做构造函数</li>\n<li>使用<code>bind</code>方法创造出来的副本函数也没有<code>prototype</code></li>\n</ul>\n</blockquote>\n<p>这两个是例外，大家记得就好，但不影响我们的理解。</p>\n<h3><code>constructor</code></h3>\n<p>这个属性也可以通俗的理解成，<strong>所有对象都拥有的一个属性</strong>。可以用<code>对象.constructor.name</code>来查看当前构造函数的名字是什么（<code>person.constructor.name</code>返回<code>People</code>，因为<code>person</code>由<code>People</code>构造实例而来）。所以我们也会看到<code>person.constructor</code>、<code>People.prototype.constructor</code>、<code>People.constructor</code>等描述。</p>\n<p>ok，介绍完这三个属性，我们再来看看这三者有什么联系。</p>\n<h3><code>__proto__</code>、<code>prototype</code>、<code>constructor</code>这三者到底是什么联系</h3>\n<p>我们看看下面例子：</p>\n<pre><code class="language-javascript">// 定义一个People构造函数\nfunction People () {\n\n}\n\n// 实例化一个person对象\nconst person = new People();\n\n// 打印true --&gt; 说明实例的__proto__与实例的构造函数的prototype相等\nconsole.log(person.__proto__ === People.prototype); \n\n// 打印true --&gt; 说明constructor是构造函数的prototype里“自身”的一个属性\nconsole.log(People.prototype.hasOwnProperty(\'constructor\'));\n\n// 打印true --&gt; 说明非顶级构造函数的prototype.constructor指回这个构造函数本身\nconsole.log(People.prototype.constructor === People);\n\n// 打印true --&gt; 说明实例的__proto__.constructor 就是 构造函数的prototype.constructor（由第一个打印可知person.__proto__ = People.prototype）\nconsole.log(person.__proto__.constructor === People.prototype.constructor);\n\n// 打印People --&gt; 说明实例的constructor指向的就是实例的构造函数\nconsole.log(person.constructor.name);\n\n// 打印fale --&gt; 说明实例自身是没有的constructor属性的\nconsole.log(person.hasOwnProperty(\'constructor\'));\n\n// 打印true, true --&gt; 说明实例自身是没有的constructor属性的\n// 它是继承自实例的__proto__.constructor，即实例的构造函数的prototype.constructor\nconsole.log(person.constructor === person.__proto__.constructor, person.constructor === People.prototype.constructor);\n\n</code></pre>\n<p>解析：</p>\n<ul>\n<li><code>__proto__</code>跟<code>prototype</code>是什么联系：<br>\n如果有一个实例，它是由一个构造函数实例而来，那么这个实例的<code>__proto__</code>一定指向这个构造函数的<code>prototype</code>，即<code>person.__proto__ = People.prototype</code></li>\n<li><code>prototype</code>跟<code>constructor</code>是什么联系：<br>\n<code>constructor</code>就是某个普通构造函数的<code>prototype</code><strong>自身</strong>的一个属性（用<code>hasOwnProperty</code>可验证），它指向的就是这个构造函数本身，即<code>People.prototype.constructor = People</code></li>\n<li><code>__proto__</code>跟<code>constructor</code>是什么联系：<br>\n<code>__proto__</code>跟<code>constructor</code>的联系跟<code>prototype</code>与<code>constructor</code>的联系一样。因为以<code>.__proto__</code>结尾的，它最后一定<strong>指向某个构造函数的原型对象（<code>People.prototype</code>）</strong>，然后又由于<code>constructor</code>是某个构造函数的<code>prototype</code><strong>自身</strong>的一个属性，因此我们可以这么看：<code>person.__proto__.constructor = People.prototype.constructor</code></li>\n</ul>\n<p>ok，看到这里，大家可以先暂停一下，整理一下思路。理一理什么是<code>__proto__</code>、<code>prototype</code>、<code>constructor</code>；然后再理一理<code>__proto__</code>、<code>prototype</code>、<code>constructor</code>这三者之间的联系。然后接下来进入最让我们蒙圈的东西——原型链。</p>\n<h3>什么是原型链</h3>\n<p>当我们用构造函数<code>People</code>实例化了一个对象<code>person</code>后，访问<code>person</code>的方法或者属性时，会先在实例<code>person</code><strong>自身</strong>找有没有对应的方法属性。有值的话，则返回值，没有的话则去<code>person.__proto__</code>（<code>People.prototype</code>）里找；有值的话，则返回值，没有的话，又会去<code>People.prototype.__proto__</code>（<code>Object.prototype</code>）里找。有值的话，则返回值；没有的话，又会去<code>Object.prototype._proto__</code>里找，但是<code>Object.prototype.__proto__</code>返回<code>null</code>，原型链到顶，一条条原型链搜索完毕，都没有，则返回<code>undefined</code>。</p>\n<p><strong>在查找的过程中会遍历以上的一条链，这条链就是原型链</strong>。上述的过程可以这么看（这个过程也是实现继承的核心）：</p>\n<p><img src="../md/about-prototype/pic_1.png" alt="原型链查找过程"></p>\n<p>经过上述的知识点，相信大家对原型链应该有个基本的认识里吧，现在我们来总结一下，看看有没有什么方法规律。</p>\n<h3>方法总结</h3>\n<p>在看到一堆类似<code>.__proto__.__proto__.__proto__</code>、<code>.__proto__.__proto__.prototype</code>、<code>.__proto__.prototype.consturtor</code>什么的，先不要慌。</p>\n<blockquote>\n<p>思想步骤：</p>\n</blockquote>\n<ol>\n<li>我们直接看最后一个属性，看看是以什么结尾</li>\n<li>然后再一步步反推前面调用的都是什么对象</li>\n<li>最后再推出它具体返回值的是什么</li>\n</ol>\n<blockquote>\n<p>规律：</p>\n</blockquote>\n<ol>\n<li>\n<p>如果最后以<code>.__proto__</code>结尾，它最后返回的一定是某个构造函数的<code>prototype</code>（<code>Object.prototype.__proto__</code>除外，它到顶了，是原型链的顶端，返回<code>null</code>）</p>\n</li>\n<li>\n<p>如果是以<code>.prototype</code>结尾，那么它前面一定是个构造函数，因为只有函数才会有<code>prototype</code>属性（因为一般以<code>.prototype</code>结尾返回的都是这个构造函数的<code>prototype</code>所有的方法与属性，所以题目很少会以<code>.prototype</code>结尾）</p>\n</li>\n<li>\n<p>如果是以<code>.constructor</code>结尾，先弄清楚前面是什么</p>\n<ul>\n<li>如果前面是<strong>实例</strong>，那它直接返回创造实例的那个构造函数；</li>\n<li>如果前面<strong>直接是顶级基类构造函数</strong>（<code>Function.constructor</code>）或者<strong>直接是普通构造函数</strong>（<code>People.constructor</code>），它会直接指向<strong>构造所有函数的顶级基类构造函数</strong><code>Function</code>（所有构造函数都是函数，都由顶级构造函数<code>Function</code>而来，所以<code>constructor</code>当然指向它；</li>\n<li>如果前面是<strong>非顶级构造函数（普通函数）的原型对象</strong>（<code>People.prototype.constructor</code>），因为实例的<code>constructor</code>是继承自<code>普通构造函数.prototype.constructor</code>，所以<code>普通构造函数.prototype.constructor</code>必须指回它自己，（<code>普通构造函数.prototype.constructor = 普通构造函数</code>）。针对这点，我们看看它是怎么继承来的。</li>\n</ul>\n<p><code>constructor</code>整个继承的流程是：在实例<code>person</code>本身查找，找不到去<code>person.__proto__</code>（<code>People.prototype</code>）找，发现有<code>People.prototype.constructor</code>，并且<code>People.prototype.constructor = People</code>返回它，所以<code>person.constructor = People</code>。\n流程如图所示：<br>\n<img src="../md/about-prototype/pic_2.png" alt="原型链图"></p>\n</li>\n</ol>\n<p>ok，经过上面总结出的思想步骤跟规律，我们来试试：</p>\n<pre><code class="language-javascript">// 定义一个People构造函数\nfunction People() {\n\n}\n\n// 实例化一个person对象\nconst person = new People();\n\n// 第一题\nconsole.log(People.__proto__);\n\n// 第二题\nconsole.log(People.constructor);\n\n// 第三题\nconsole.log(person.prototype);\n\n// 第四题\nconsole.log(person.__proto__.__proto__);\n\n// 第五题\nconsole.log(People.__proto__.prototype);\n\n// 第六题\nconsole.log(person.__proto__.__proto__.constructor);\n\n// 第七题\nconsole.log(Object.__proto__);\n</code></pre>\n<ul>\n<li>\n<p>我们以第一道题为例，解析一下：</p>\n<ol>\n<li>先看是以什么结尾。以<code>.__proto__</code></li>\n<li>ok，心里有个大概了，根据规律总结第一点，它肯定返回某个构造函数的<code>prototype</code></li>\n<li>再反推一下前面调用的都是什么对象。前面是<code>People</code>，<code>People</code>是什么？是构造函数，函数都有一个顶级基类构造函数，那就是<code>Function</code>，所以<code>People.__proto__</code>返回的就是<code>Function.prototype</code>。</li>\n</ol>\n</li>\n<li>\n<p>我们以第二道题为例，解析一下：</p>\n<ol>\n<li>先看是以什么结尾。以<code>.constructor</code></li>\n<li>调用对象直接是普通构造函数，根据规律总结第三点的第二小点，直接得出<code>Function</code></li>\n</ol>\n</li>\n<li>\n<p>我们再以第六道题为例，解析一下：</p>\n<ol>\n<li>先看是以什么结尾。以<code>.constructor</code></li>\n<li>再反推一下前面是调用的都是什么对象。先看<code>person.__proto__</code>，返回的是<code>People.prototype</code>，那这题就变成了<code>People.prototype.__proto__.constructor</code>。再继续看，<code>People.prototype.__proto__</code>返回的是什么，<code>Object.prototype</code>，那这题实际就是<code>Object.prototype.constructor</code>。根据规律总结第三点的第三小点，那它返回的就是<code>Object</code>本身。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>大家一定要注意，<code>Object.__proto__</code>跟<code>Function.__proto__</code>，<code>Object</code>跟<code>Function</code>都是顶级构造函数，所以<code>Object.__proto__</code>、<code>Function.__proto__</code>返回的都是<code>Function.prototype</code></p>\n</blockquote>\n<h3>牛刀小试</h3>\n<p>根据上面对<code>__proto__</code>、<code>prototype</code>、<code>constructor</code>的特点总结，还有方法总结，我们可以拿下面这道题来试试，如果大家都可以正确无误的答出来，那大家对原型应该就了解的差不多了</p>\n<pre><code class="language-javascript">function Person(name) {\n    this.name = name\n}\nvar p2 = new Person(\'king\');\n\nconsole.log(p2.__proto__); // Person.prototype\n\nconsole.log(p2.__proto__.__proto__); // Object.prototype\n\nconsole.log(p2.__proto__.__proto__.__proto__); // null\n\nconsole.log(p2.__proto__.__proto__.__proto__.__proto__); // 报错\n\nconsole.log(p2.constructor); // Person\n\nconsole.log(p2.prototype); // undefined\n\nconsole.log(Person.constructor); // Function\n\nconsole.log(Person.prototype); // 输出Person.prototype这个对象里所有的方法和属性\n\nconsole.log(Person.prototype.constructor); // Person\n\nconsole.log(Person.prototype.__proto__); // Obejct.prototype\n\nconsole.log(Person.__proto__); // Fuction.prototype\n\nconsole.log(Function.prototype.__proto__); // Obeject.prototype\n\nconsole.log(Function.__proto__); // Function.prototype\n\nconsole.log(Object.__proto__); // Function.prototype\n\nconsole.log(Object.prototype.__proto__); // null\n</code></pre>\n<h3>最后</h3>\n<p>原型、原型链本来就挺绕的，所以大家先了解<code>__proto__</code>、<code>prototype</code>、<code>constructor</code>是什么，再明白它们之间的是什么联系，循环渐进。等理解以后，多画几遍原型链图加深理解。OK，最后祭出一张原型链图：</p>\n<blockquote>\n<p><strong>红色链表示的就是实例<code>person</code>原型链</strong></p>\n</blockquote>\n<p><img src="../md/about-prototype/pic_3.png" alt="原型链图"></p>\n<p>写着写着，发现又写了一大堆，希望能够帮助到大家。如果觉得觉得写得好的，有帮助到的，欢迎大家点赞，也欢迎大家评论交流。</p>\n<p>既然明白了什么是原型链，那还不赶紧趁热打铁，进阶看看什么是<a href="https://limingcan562.github.io/posts/js-inherit">JS继承</a>吧！</p>\n'}},312:function(o,e){o.exports={attributes:{title:"关于Webpack5搭建的一些体会",des:"Webpack4升级Webpack5后，配置更加精简了，同时感受到看文档的重要性",createTime:"2022-2-4"},html:'<h2>前言</h2>\n<p>在从<code>Webpack4</code>到<code>Webpack5</code>的升级过程中，即使以前已经搭建过<code>Webpack4</code>，但是搭建<code>Webpack5</code>的过程中还是有点痛苦。因为<code>Webpack</code>提供的功能方法实在是太多了，很庞大的一个体系，所以搭建完感触还是很多的，<strong>发现不能一味的从网上找，还是得看文档</strong>。<br>\n看完文档才发现原来<code>Webpack5</code>里面已经精简了很多插件了，不需要额外安装其他插件，很多以前概念比较模糊的东西，看了文档还是比较清晰的。大家有兴趣的话可以<code>Fork</code>我的<a href="https://github.com/limingcan562/webpack5-boilerplate"><code>webpack5-boilerplate</code></a>学习交流，建议大家多敲敲多试试，过程虽然有点痛苦，但是一定会有收获的。<br>\n本文讲解，需要一定<code>Webpack4</code>基础，还没有搭建过<code>Webpack4</code>的同学，可以看看这篇<a href="https://itxiaohao.github.io/passages/webpack4-learn-introduction/"><code>Webpack4搭建</code></a><br>\n下面的讲解，都基于<a href="https://github.com/limingcan562/webpack5-boilerplate"><code>webpack5-boilerplate</code></a>这个项目。</p>\n<h2><code>Webpack</code>大体框架</h2>\n<p>首先我们对<code>Webpack</code>得有一个大体的框架认识</p>\n<pre><code class="language-javascript">// webpack.config.js\nmodule.exports = {\n    // 入口\n    entry: {},\n\n    // 打包输出\n    output: {},\n\n    // 配置模块如何解析\n    resolve: {},\n\n    // 配置各种loader\n    moudle: {},\n\n    // 配置插件\n    plugins: [],\n\n    // 优化（可以进行代码分割）\n    optimization: {},\n\n    // webpack-dev-server 开发时的配置，一般用于development模式\n    devServer: {}\n};\n</code></pre>\n<h2>所需要的<code>Loader</code></h2>\n<h3><code>CSS</code>类的<code>Loader</code></h3>\n<ul>\n<li><code>css-loader</code></li>\n<li><code>css-minimizer-webpack-plugin</code></li>\n<li><code>mini-css-extract-plugin</code></li>\n<li><code>less-loader</code></li>\n<li><code>less</code></li>\n<li><code>style-loader</code></li>\n<li>...</li>\n</ul>\n<p>目前我暂时用到的就这些</p>\n<h3>解析<code>ES6</code>类的<code>Loader</code></h3>\n<ul>\n<li><code>@babel/core</code></li>\n<li><code>@babel/plugin-transform-runtime</code></li>\n<li><code>@babel/preset-env</code></li>\n<li><code>babel-loader</code></li>\n<li><code>core-js</code></li>\n</ul>\n<h3>解析<code>Html</code>类的<code>Loader</code></h3>\n<ul>\n<li><code>html-webpack-plugin</code></li>\n</ul>\n<h3><code>Webpack5</code>不需要用到的依赖</h3>\n<ul>\n<li><s><code>url-loader</code></s></li>\n<li><s><code>file-loader</code></s></li>\n<li><s><code>clean-webpack-plugin</code></s></li>\n<li><s><code>@babel/polyfill</code></s></li>\n<li><s><code>@babel/runtime</code></s></li>\n<li><s><code>optimize-css-assets-webpack-plugin</code></s></li>\n</ul>\n<h3>最后依赖列表预览</h3>\n<pre><code class="language-json">&quot;devDependencies&quot;: {\n    &quot;@babel/core&quot;: &quot;^7.16.12&quot;,\n    &quot;@babel/plugin-transform-runtime&quot;: &quot;^7.16.10&quot;,\n    &quot;@babel/preset-env&quot;: &quot;^7.16.11&quot;,\n    &quot;babel-loader&quot;: &quot;^8.2.3&quot;,\n    &quot;css-loader&quot;: &quot;^6.5.1&quot;,\n    &quot;css-minimizer-webpack-plugin&quot;: &quot;^3.4.1&quot;,\n    &quot;filemanager-webpack-plugin&quot;: &quot;^6.1.7&quot;,\n    &quot;html-webpack-plugin&quot;: &quot;^5.5.0&quot;,\n    &quot;less&quot;: &quot;^4.1.2&quot;,\n    &quot;less-loader&quot;: &quot;^10.2.0&quot;,\n    &quot;mini-css-extract-plugin&quot;: &quot;^2.5.3&quot;,\n    &quot;style-loader&quot;: &quot;^3.3.1&quot;,\n    &quot;webpack&quot;: &quot;^5.67.0&quot;,\n    &quot;webpack-cli&quot;: &quot;^4.9.2&quot;,\n    &quot;webpack-dev-server&quot;: &quot;^4.7.3&quot;,\n    &quot;webpack-merge&quot;: &quot;^5.8.0&quot;\n},\n&quot;dependencies&quot;: {\n    &quot;core-js&quot;: &quot;^3.20.3&quot;\n},\n</code></pre>\n<blockquote>\n<p><a href="https://github.com/limingcan562/webpack5-boilerplate"><code>webpack5-boilerplate</code></a>这个脚手架，核心的就这些依赖，另外需要的依赖再自己装就好了。是不是觉得依赖少了很多，我是顿时觉得很舒服。接下来讲一下这些不需要用到的插件，如何在<code>Webpack5</code>里面用别的方式替代。</p>\n</blockquote>\n<h2>使用<code>Asset Module</code>模块，来管理资源</h2>\n<blockquote>\n<p>官方解释：资源模块(<code>asset module</code>)是一种模块类型，它允许使用资源文件（字体，图标等）而无需配置额外 loader。</p>\n</blockquote>\n<p>以编译图片为例，所以如果我们要编译图片：</p>\n<pre><code class="language-javascript">const \nmaxSize = 10 * 1024,\noutImageFileName = \'img/\',\nproResFileName = \'assets/\';\n\n/**\n * @maxSize 如果图片小于10Kb，会被转为base64\n * @outImageFileName 要导出到哪个文件夹，如果写在filename配置里面，则会导出到这个文件夹上\n * @proResFileName outputPath指的也是把该资源存放到proResFileName文件夹下\n */\nmodule: {\n    rules: [\n        {\n            test: /\\.(png|svg|jpg|jpeg|gif)$/i,\n            type: \'asset\',\n            // 设置图片导出大小，如果小于预设的值，则会被转化成base64\n            parser: {\n                dataUrlCondition: {\n                    maxSize\n                }\n            },\n\n            // 设置导出的路径为 img\n            generator: {\n                filename: `${outImageFileName}[name]-[hash:2][ext][query]`,\n                outputPath: proResFileName\n            }\n        },\n    ]\n}\n</code></pre>\n<p>参考文章：</p>\n<ul>\n<li><a href="https://webpack.docschina.org/guides/asset-modules/"><code>Webpack</code>资源模块</a></li>\n<li><a href="https://webpack.docschina.org/configuration/module/">模块</a></li>\n</ul>\n<h2>使用<code>output</code>里面配置，在生成文件之前清空<code>output</code>目录的内容</h2>\n<p>这样我们就可以不需要安装<code>clean-webpack-plugin</code>这个插件了</p>\n<pre><code class="language-javascript">output: {\n    clean: true\n};\n</code></pre>\n<p>参考文章：</p>\n<ul>\n<li><a href="https://webpack.docschina.org/configuration/output/#outputclean"><code>output.clean</code></a></li>\n</ul>\n<h2>使用<code>mini-css-extract-plugin</code>插件来压缩<code>css</code>代码</h2>\n<pre><code class="language-javascript">// Webpack5压缩配置\noptimization: {\n    minimizer: [\n        // 压缩css\n        new CssMinimizerPlugin(),\n\n        // \'...\' 来访问默认值。（不加的话，js不会压缩）\n        \'...\'\n    ],\n},\n</code></pre>\n<pre><code class="language-javascript">// Webpack4压缩配置\nconst OptimizeCssAssetsPlugin = require(\'optimize-css-assets-webpack-plugin\');\n\nplugins: [\n    // 压缩css\n    new OptimizeCssAssetsPlugin({\n        assetNameRegExp: /\\.css$/g,\n        cssProcessor: require(\'cssnano\'), //用于优化\\最小化 CSS 的 CSS 处理器，默认为 cssnano\n        cssProcessorOptions: { safe: true, discardComments: { removeAll: true } }, //传递给 cssProcessor 的选项，默认为{}\n        canPrint: true //布尔值，指示插件是否可以将消息打印到控制台，默认为 true\n    }),\n]\n</code></pre>\n<p><code>Webpack5</code>压缩<code>css</code>的配置对比起<code>Webpack4</code>的更加简单。</p>\n<p>参考文章：</p>\n<ul>\n<li><a href="https://webpack.docschina.org/plugins/css-minimizer-webpack-plugin/"><code>CssMinimizerWebpackPlugin</code></a></li>\n</ul>\n<h2><code>Babel</code>依赖配置</h2>\n<ul>\n<li><code>@babel/cli</code>：如果想用<code>npm</code>在终端编译<code>Babel</code>，则需要安装它</li>\n<li><code>@babel/core</code>：这个<code>Babel</code>核心<code>npm</code>包</li>\n<li><code>@babel/preset-env</code>：个人理解它就是个集合包，里面有很多<code>Babel</code>的插件跟语法规则，并且它已经内置了<code>@babel/runtime</code>包了。如果在<code>Babel.config.json</code>里面配置它，它还可以有针对性的对语法转化跟<code>polyfill</code>的部分引入</li>\n<li><code>@babel/polyfill</code>：<code>Babel</code>默认只转换语法，不转换新的<code>API</code>（如<code>Promise、Map、Symbol</code>等），所以<code>@babel/polyfill</code>的作用就像一个叠片，让所有浏览器都支持新的<code>API</code></li>\n<li><code>@babel/plugin-transform-runtime</code>有三大作用（摘自网上）：\n<ol>\n<li>自动移除语法转换后内联的辅助函数（<code>inline Babel helpers</code>），使用<code>@babel/runtime/helpers</code>里的辅助函数来替代；</li>\n<li>当代码里使用了<code>core-js</code>的<code>API</code>，自动引入<code>@babel/runtime-corejs3/core-js-stable/</code>，以此来替代全局引入的<code>core-js/stable</code>（避免污染全局）;</li>\n<li>当代码里使用了<code>Generator/async</code>函数，自动引入<code>@babel/runtime/regenerator</code>，以此来替代全局引入的<code>regenerator-runtime/runtime</code>；</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>注意：从<code>Babel7.4</code>开始，<code>@babel/polyfill</code>就不再推荐使用了，他变成了两个<code>npm</code>集合包的组成：<code>core-js</code>与<code>regenerator-runtime</code></p>\n</blockquote>\n<h3>关于<code>@babel/preset-env</code>配置项相关解析</h3>\n<p>先看看以下配置：</p>\n<pre><code class="language-json">// babel.config.json\n&quot;presets&quot;: [\n    [\n        &quot;@babel/env&quot;,\n        {\n            &quot;useBuiltIns&quot;: &quot;usage&quot;,\n            &quot;modules&quot;: false\n        }\n    ]\n],\n&quot;plugins&quot;: [\n    &quot;@babel/plugin-transform-runtime&quot;\n]\n</code></pre>\n<ul>\n<li>当<code>useBuiltIns: &quot;entry&quot;</code>时，需要手动在我们的文件内<code>import \'@babel/polyfill\'</code>，但是此时会引入所有当前<code>browserslist</code>不支持的<code>API</code></li>\n<li>当<code>useBuiltIns: &quot;usage&quot;</code>时，不需要手动在我们的文件内<code>import \'@babel/polyfill\'</code>，并且会自动引入当前<code>browserslist</code>不支持的<code>API</code>，并且是当前<code>js</code>所用到的<code>es6+</code>模块，不会全部都引入</li>\n<li>当<code>modules: &quot;auto&quot;</code>或者<code>默认值</code>时，我们当前开发<code>js</code>如果有<code>import</code>别的模块，则它会被编译成<code>require</code>的方式</li>\n<li>当<code>modules: &quot;false&quot;</code>时，我们当前开发<code>js</code>如果有<code>import</code>别的模块，则它编译的时候会保持<code>import</code>的方式，利于<code>Webpack</code>一类的打包工具，进行<code>tree shaking</code></li>\n</ul>\n<h3>对<code>Polyfill</code>补全方式的选择</h3>\n<ul>\n<li><strong>全局注入</strong>\n<ul>\n<li>就是通过<code>polyfill</code>将当前<code>browserslist</code>不支持的<code>API</code>进行注入，注入后可以通过<code>window.[API]</code>访问到</li>\n<li>例如全局注入了<code>Promise</code>，则可以通过<code>window.Promise</code>访问到</li>\n<li>一般适用于整个前端业务项目</li>\n</ul>\n</li>\n</ul>\n<p>相关配置如下：</p>\n<pre><code class="language-json">// babel.config.json\n&quot;presets&quot;: [\n    [\n        &quot;@babel/env&quot;,\n        {\n            &quot;useBuiltIns&quot;: &quot;usage&quot;,\n            &quot;modules&quot;: false\n        }\n    ]\n],\n&quot;plugins&quot;: [\n    &quot;@babel/plugin-transform-runtime&quot;\n]\n</code></pre>\n<ul>\n<li><strong>局部注入</strong>：\n<ul>\n<li>就是通过<code>@babel/plugin-transform-runtime</code>，<code>@babel/runtime-corejs3</code>配合使用将当前<code>browserslist</code>不支持的<code>API</code>进行注入</li>\n<li>注入后可以不能通过<code>window.[API]</code>访问到。因为它只是局部注入，不会污染全局</li>\n<li>一般适用于开发<code>js</code>库</li>\n</ul>\n</li>\n</ul>\n<p>相关配置如下：</p>\n<pre><code class="language-javascript">npm i @babel/runtime-corejs3 -S\n</code></pre>\n<pre><code class="language-json">// babel.config.json\n&quot;presets&quot;: [\n    &quot;@babel/env&quot;\n],\n&quot;plugins&quot;: [\n    [\n        &quot;@babel/plugin-transform-runtime&quot;,\n        {\n            &quot;helpers&quot;: true,\n            &quot;corejs&quot;: 3, // 如果为false，则不注入，但是此时代码所在的整体项目需要支持缺失的API\n            &quot;regenerator&quot;: true,\n            &quot;absoluteRuntime&quot;: false,\n            &quot;version&quot;: &quot;7.17.0&quot;,\n            &quot;useESModules&quot;: true\n        }\n    ]\n]\n</code></pre>\n<h3>其他</h3>\n<p>有时我们会自己开发一个<code>library</code>（自己封装的库），然后输出打包后的<code>library</code>，再<code>import</code>到自己的工程里；<br>\n或者将第三方的库下载到本地，然后在<code>import</code>到自己的工程里，这里以<code>vconsole</code>为例，可能会出现以下报错：</p>\n<pre><code class="language-javascript">export \'default\' (imported as \'fecmPlugin\') was not found in \'../plugins/vconsole.min\' (module has no exports)\n</code></pre>\n<p>这时我们可以添加一个<a href="https://www.babeljs.cn/docs/babel-plugin-transform-modules-commonjs"><code>Babel</code>插件</a>，来解决这个问题<br>\n配置如下：</p>\n<pre><code class="language-babel.config.json">&quot;plugins&quot;: [\n    &quot;@babel/plugin-transform-modules-commonjs&quot;\n]\n</code></pre>\n<p>参考文章：</p>\n<ul>\n<li><a href="https://www.jiangruitao.com/babel/"><code>Babel</code>教程</a></li>\n<li><a href="https://itxiaohao.github.io/passages/webpack4-Babel7/"><code>Webpack4</code>搭建</a></li>\n</ul>\n<h2>关于<code>devServer</code>配置的理解</h2>\n<p>我想大家最懵圈的应该就是<code>devServer.static</code>（<code>Webpack5</code>是<code>static</code>，<code>Webpack4</code>是<code>contentBase</code>）这个配置了吧。是不是一直觉得，如果把里面的路径配置指向了我们打包出来的文件夹名字（<code>dist</code>），然后开启了<code>webpack-dev-server</code>服务器，就是访问的我们打包的那个资源（<code>dist</code>），其实并不是。这里大家可以自己建一个最简单的<code>demo</code>，然后配置改成下面这样：</p>\n<pre><code class="language-javascript">output: {\n    path: path.resolve(__dirname, `build`),\n},\ndevServer: {\n    static: {\n        directory: path.resolve(__dirname, `outDir`),\n    },\n}\n</code></pre>\n<p>此时打包出来的文件夹是<code>build</code>，但是我们开启服务器访问的时候，访问是<code>outDir</code>文件夹，结果页面显示的还是我们的开发的<code>index.html</code>的内容，这就说明<code>devServer.static</code>的配置，根本就不是控制开启了<code>webpack-dev-server</code>服务器后访问的文件目录。这是经过本人测试，分析后的个人理解。</p>\n<blockquote>\n<p><code>devServer.static</code>，实际上指的是：<strong>一个存放，不经过<code>Webpack</code>编译的静态资源目录，他是一个目录</strong>。它的功能就很像是<code>vue-cli</code>里面的<code>public</code>文件夹，我们开发的时候，可以通过<code>./</code>或者<code>../</code>访问到那个资源（具体看目录关系）。</p>\n</blockquote>\n<h3>怎么访问到<code>devServer.static.directory</code>里面的文件</h3>\n<p>首先，我们先清楚这几点：</p>\n<ol>\n<li>开启<code>webpack-dev-server</code>服务器时，以<a href="https://github.com/limingcan562/webpack5-boilerplate"><code>webpack5-boilerplate</code></a>为例，我们的代码会根据我们的配置，在内存中生成一个打包文件，保存在内存中的打包文件目录结构：<pre><code>(http://localhost:8080/)\n├── js\n├── img\n├── font\n├── media\n├── favicon.ico\n├── index.html\n└── share.html\n</code></pre>\n</li>\n<li>开启<code>webpack-dev-server</code>服务器时，<code>devServer.static.directory</code>里面的文件会直接被映射到根目录下</li>\n<li><code>devServer.static.directory</code>，默认指向的是<code>public</code>文件夹。</li>\n</ol>\n<p>OK，我们在根目录下新建一个<code>public</code>的文件夹，里面放一个<code>test.txt</code>文件。开启<code>webpack-dev-server</code>，打开<code>http://localhost:8080/test.txt</code>，我们就可以访问到这个不经打包的静态资源了。此时保存在内存中的文件目录结构就变成了：</p>\n<pre><code>(http://localhost:8080/)\n├── js\n├── img\n├── font\n├── media\n├── favicon.ico\n├── test.txt （直接被映射到根目录下）\n├── index.html\n└── share.html\n</code></pre>\n<p>所以想要访问<code>devServer.static.directory</code>的内容就是：<code>http://localhost:8080/（文件名字）</code>。</p>\n<blockquote>\n<p>注意：\n如果在<code>public</code>里面新建一个<code>index.html</code>，访问<code>http://localhost:8080/index.html</code>或者<code>http://localhost:8080/</code>时，内容是我们的开发的<code>index.html</code>模板，这是因为我们的配置把编译后的<code>index.html</code>输出在<code>dist</code>文件夹根目录了，此时覆盖掉了<code>public/index.html</code>(可以在插件<code>HtmlWebpackPlugin</code>，把输的<code>filename</code>，设置为<code>filename: index2.html</code>，在<code>public</code>下新建一个<code>index.html</code>，此时访问<code>http://localhost:8080/</code>就是<code>public</code>里面的<code>index.html</code>)<br>\n所以我们在<code>public</code>文件夹里面，要避免与被编译的文件同名，否则会被覆盖掉。</p>\n</blockquote>\n<h2>关于<code>devServer.devMiddleware.publicPath</code>配置说明</h2>\n<p><code>devServer.devMiddleware.publicPath</code>对应的是<code>Webpack4</code>里面的<code>devServer.publicPath</code>，以下简称<code>publicPath</code>。<br>\n在没有配置<code>publicPath</code>的时候，我们开启<code>webpack-dev-server</code>，访问<code>http://localhost:8080/</code>得到的是覆盖掉<code>public/index.html</code>的编译后的模板<code>index.html</code>。因为<code>publicPath</code>默认值是：<code>\'\'</code>指向根目录，所以我们访问<code>http://localhost:8080/</code>就是根目录，不用在后面加路径。<br>\n但是如果我们想类似以下访问我们的开发页面：<code>http://localhost:8080/test/</code>，我们只要将配置设置成：</p>\n<pre><code class="language-javascript">output: {\n    publicPath: \'/test/\',\n},\ndevServer: {\n    /**\n     * 表示打包生成的静态文件所在的位置，意思是url访问的路径\n     * 改变dist访问的路径，outpath需要跟他一致，启动访问的url为http://localhost:8080/test/index.html\n     */\n    devMiddleware: {\n        publicPath: \'/test/\',\n    },\n}\n</code></pre>\n<p>此时我们访问的开发页面的路径就是：<code>http://localhost:8080/test/</code></p>\n<blockquote>\n<p>注意：<code>output.publicPath</code>与<code>devServer.devMiddleware.publicPath</code>要始终保持一致，不然会有问题</p>\n</blockquote>\n'}},313:function(o,e){o.exports={attributes:{title:"JS继承面试的时候怎么说？答应我，不要再死记硬背了好吗？",des:"深入理解JS继承，不要再背继承八股文啦",createTime:"2022-11-13"},html:"<h2><code>JS继承</code>继承面试的时候怎么说？答应我不要再死记硬背了好吗？</h2>\n<h3>前言</h3>\n<p><code>JS</code>继承这块，<code>ES6</code>已经有<code>class</code>很香的语法糖实现了，<code>ES6</code>之前那些实现继承的方法真的又多又长，说句心里话，能不学真的不想再学，但是没办法，面试还是要搞你呀，所以这两天看回<code>ES6</code>之前的继承，发现还是蛮有意思的。写这篇文章也是对自己的一个梳理总结，也希望能帮助到大家弄懂继承这块，这样就不需要再死记硬背八股文，面试自由发挥就好。<br>\n<code>JS</code>的继承，核心就是靠<strong>原型链</strong>完成。如果大家对原型链还不是很清楚，可以先读读我写的这篇关于原型链的文章——<a href=\"https://limingcan562.github.io/posts/about-prototype\"><code>__proto__</code>、<code>prototype</code>、<code>constructor</code>、原型链，真没那么难！教你怎么套用方法直接判断</a>。</p>\n<p>文章蛮长，大家可以分成两部分来看。原型链继承、盗用构造函数继承、组合继承为一部分，原型式继承、寄生式继承、寄生式组合继承为一部分。</p>\n<p>为了让大家更好的理解，后面的例子，我们都用：</p>\n<ul>\n<li><code>Animal</code>作为父类</li>\n<li><code>Cat</code>为子类</li>\n<li><code>cat</code>为子类<code>Cat</code>实例一，<code>small_cat</code>为子类<code>Cat</code>实例二</li>\n</ul>\n<h3><code>JS</code>继承最常见的<strong>六种</strong>方式</h3>\n<ul>\n<li>原型链继承</li>\n<li>盗用构造函数继承</li>\n<li>组合继承</li>\n<li>原型式继承</li>\n<li>寄生式继承</li>\n<li>寄生式组合继承</li>\n</ul>\n<h3>原型链继承</h3>\n<blockquote>\n<p>原理：为什么叫原型链继承，我们可以这样记，因为核心就是我们会重写某个构造函数的原型（<code>prototype</code>），使其指向父类的一个实例，以此让它们的原型链不断串联起来，从而实现继承。</p>\n</blockquote>\n<p>将子类<code>Cat.prototype</code>指向父类<code>Animal</code>的一个实例（<code>Cat.prototype = new Animal()</code>），这样我们就完成了一个原型链继承。来看看具体例子：</p>\n<pre><code class=\"language-javascript\">// 定义一个父类\nfunction Animal() {\n  this.like = ['eat', 'drink', 'sleep'];\n}\n\n// 为父类的原型添加一个run方法\nAnimal.prototype.run = function() {\n  console.log('跑步');\n}\n\n// 定义一个子类\nfunction Cat() {\n  this.name = 'limingcan';\n}\n\n// 核心：将Cat的原型指向父类Animal的一个实例\nCat.prototype = new Animal();\n\n// 实例cat.constructor是来自Cat.prototype.constructor\n// 不矫正的cat.constructor话，当前的cat.constructor指向的是Animal\n// 因为Cat.prototype被重写，constructor被指向了new Animal().__proto__.constructor，相当于Animal.prototype.constructor\nCat.prototype.constructor = Cat;\n\n// 实例一个由子类 new 出来的对象\nconst cat = new Cat();\n\ncat.run();\n\nconsole.log(cat);\n\n</code></pre>\n<p>打印：\n<img src=\"../md/js-inherit/pic_0.png\" /></p>\n<p>解析：</p>\n<blockquote>\n<p>当我们执行<code>Cat.prototype = new Animal();</code>这句时，发生了什么：</p>\n</blockquote>\n<p>它把<code>Cat.prototype</code>整个重写了，并将两者通过原型链联系起来，从而实现继承。因为我们将<code>Cat.prototype</code>指向了父类<code>Animal</code>的一个实例，我们暂时把这个实例叫做<code>中介实例X</code>，这个<code>中介实例X</code>自己也有一个<code>__proto__</code>，它又指向了<code>Animal.prototype</code>。所以当实例<code>cat</code>在自身找不到属性方法时，它会去<code>cat.__proto__</code>（相当于<code>Cat.prototype</code>，但是<code>Cat.prototype</code>被重写成了<code>中介实例X</code>，所以也是去<code>中介实例X</code>里面找）找。如果<code>中介实例X</code>也找不到，就会去<code>中介实例X.__proto__</code>（相当于<code>Animal.prototype</code>）找。有值的话，则返回值；没有值的话又会去<code>Animal.prototype.__proto__</code>（相当于<code>Object.prototype</code>）找。有值的话，则返回值；没有值的话又会去<code>Object.prototype.__proto__</code>找，但是<code>Object.prototype.__proto__</code>返回<code>null</code>，原型链到顶，一条条原型链搜索完毕，都没有，则返回<code>undefined</code>。所以这就是为什么实例<code>cat</code><strong>自身</strong>没有<code>like</code>属性跟<code>run</code>方法，但是还是可以访问。上述的大致过程，我们可以这样看：\n<img src=\"../md/js-inherit/pic_1.png\" /></p>\n<p>这条链有点绕，所以这也是为什么大家对原型链继承总是那么晕头转向的原因。建议读的时候想一下这条链是什么样的，怎么来的。读到这里的同学，如果感觉自己看的不是很懂，那暂时不用继续往下看啦，说明原型链还没有弄清楚，建议还是先把原型链弄清楚，这样才好理解继承。<a href=\"https://limingcan562.github.io/posts/about-prototype\">去搞懂</a></p>\n<p>如果我们这时候给实例<code>cat</code>的<code>like</code>属性<code>push</code>一个值，看看下面例子：</p>\n<pre><code class=\"language-javascript\">// 定义一个父类\nfunction Animal() {\n  this.like = ['eat', 'drink', 'sleep'];\n}\n\n// 为父类的原型添加一个run方法\nAnimal.prototype.run = function() {\n  console.log('跑步');\n}\n\n// 定义一个子类\nfunction Cat() {\n  this.name = 'limingcan';\n}\n\n// 核心：将Cat的原型指向父类Animal的一个实例\nCat.prototype = new Animal();\n\n// 实例cat.constructor是来自Cat.prototype.constructor\n// 不矫正的cat.constructor话，当前的cat.constructor指向的是Animal\n// 因为Cat.prototype被重写，constructor被指向了new Animal().__proto__.constructor，相当于Animal.prototype.constructor\nCat.prototype.constructor = Cat;\n\n// 实例一个由子类 new 出来的对象\nconst cat = new Cat();\n\n// 给like属性push一个play值\ncat.like.push('play');\n\n// 实例第二个对象\nconst small_cat = new Cat();\n\nconsole.log(cat.like);\n\nconsole.log(small_cat.like);\n\nconsole.log(cat.like === small_cat.like);\n\n</code></pre>\n<p>打印：<br>\n<img src=\"../md/js-inherit/pic_2.png\" /></p>\n<p>我们会发现，如果我们修改实例<code>cat</code>的属性，并且该属性是引用类型的话，后续实例化出来的对象，<strong>都会被影响到</strong>。因为<code>cat</code>跟<code>small_cat</code><strong>自身</strong>没有<code>like</code>属性，它们的<code>like</code>都继承自<code>Cat.prototype</code>，指向的是的同一份地址。</p>\n<blockquote>\n<p>如果想要两个实例修改<code>like</code>互不影响，只能给他们自身增加一个<code>like</code>属性（<code>cat.like = ['eat', 'drink', 'sleep', 'play'];cat_small.like = ['food']</code>。如果自身有属性，是不会去<code>prototype</code>查找的，它们是两个实例自己独有的属性，指向不同地址），但这样就失去了继承的意义了。</p>\n</blockquote>\n<p>总结：</p>\n<ul>\n<li>\n<p>优点：</p>\n<ul>\n<li>实现相对简单</li>\n<li>子类实例可以直接访问到父类实例或父类原型上的属性方法</li>\n</ul>\n</li>\n<li>\n<p>缺点：</p>\n<ul>\n<li>父类所有的引用类型属性都会被实例出来的对象共享，所以修改一个实例对象的引用类型属性，会导致所有实例对象受到影响</li>\n<li>实例化时，不能传参数</li>\n</ul>\n</li>\n</ul>\n<p>因此为了解决原型链继承的缺点，又搞了个盗用构造函数继承的方式。</p>\n<h3>盗用构造函数继承</h3>\n<p>盗用构造函数继承，也叫借用构造函数继承，它可以解决原型链继承带来的缺点。</p>\n<blockquote>\n<p>原理：在子类构造函数中，调用父类构造函数方法，但通过<code>call</code>或者<code>apply</code>方法改变了父类构造函数内<code>this</code>的指向，使得子类实例出来的对象，<strong>自身</strong>拥有来自父类构造函数的方法跟属性，且分别独立，互不影响。</p>\n</blockquote>\n<p>来看看具体例子：</p>\n<pre><code class=\"language-javascript\">// 定义一个父类\nfunction Animal(name) {\n  this.name = name;\n  this.like = ['eat', 'drink', 'sleep'];\n  this.play = function() {\n    console.log('到处玩');\n  }\n}\n\n// 为父类的原型添加一个run方法\nAnimal.prototype.run = function() {\n  console.log('跑步');\n}\n\n// 定义一个子类\nfunction Cat(name, age) {\n  Animal.call(this, name);\n  this.age = age;\n}\n\n// 实例一个由子类 new 出来的对象\nconst cat = new Cat('limingcan', 27);\n\n// 给实例cat的like属性push一个toys值\ncat.like.push('toys');\n\n// 实例第二个对象\nconst small_cat = new Cat('mimi', 100);\n\nconsole.log(cat);\n\nconsole.log(small_cat);\n\nconsole.log(cat.run);\n\nconsole.log(small_cat.run);\n\n</code></pre>\n<p>打印：\n<img src=\"../md/js-inherit/pic_3.png\" /></p>\n<p>从打印我们可以看出：</p>\n<ol>\n<li>实例化子类<code>Cat</code>时，可以传入参数</li>\n<li>父类<code>Animal</code>里的属性方法，都被添加到实例<code>cat</code>跟实例<code>small_cat</code>的<strong>自身</strong>里了（因为子类<code>Cat</code>调用了<code>call</code>方法，某种程度来说继承了父类<code>Animal</code>里的属性方法）</li>\n<li>修改实例<code>cat</code>不会影响到实例<code>small_cat</code>（因为实例出来的对象，所有的属性、方法都是添加到实例对象<strong>自身</strong>，而不是添加到实例对象的原型上，它们是完全独立，指向的都是不同的地址）</li>\n<li>打印<code>run</code>方法，输出都是<code>undefined</code>，说明实例没有继承父类<code>Animal</code>原型上的方法（实例的原型链没有跟父类<code>Animal</code>原型链打通，因此原型链上搜索不到<code>run</code>方法，可以跟原型链继承对比想想）</li>\n<li>子类的原型<code>Cat.prototype</code>与父类原型<code>Animal.prototype</code>没有打通，因为<code>Cat.prototype.__proto__</code>直接指向了<code>Object.prototype</code>，如果打通了的话，应该是<code>Cat.prototype.__proto__</code>指向<code>Animal.prototype</code>，这也是为什么实例<code>cat</code>没有继承父类<code>run</code>方法的原因，因为访问不到。</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li>\n<p>优点：</p>\n<ul>\n<li>实例化时，可以传参</li>\n<li>子类通过<code>call</code>或<code>apply</code>方法，将父类里的所有属性、方法复制到实例对象的<strong>自身</strong>，而不是共享原型链上同一个属性，所以修改一个实例对象的引用类型属性时，不会导致所有实例对象受到影响</li>\n</ul>\n</li>\n<li>\n<p>缺点：</p>\n<ul>\n<li>无法继承父类原型上的属性与方法</li>\n</ul>\n</li>\n</ul>\n<p>我们通过借用构造函数继承的方法，解决了原型链继承的缺点。但是又产生了一个新的问题——子类无法继承父类原型（<code>Animal.prototype</code>）上的属性与方法，如果我们把这两种方式结合一下，会不会好点呢，于是有了组合继承这个继承方式。</p>\n<h3>组合继承</h3>\n<p>组合继承顾名思义就是，利用原型链继承跟借用构造函数继承相结合，而创造出来的一种新的继承方式，是不是很好记。</p>\n<blockquote>\n<p>原理：利用原型链继承，实现实例对父类原型（<code>Animal.protoytype</code>）上的方法与属性继承；利用借用构造函数继承，实现实例对父类构造函数（<code>function Animal() {}</code>）里方法与性的继承，并且解决原型链继承的缺陷。</p>\n</blockquote>\n<p>来看看具体例子：</p>\n<pre><code class=\"language-javascript\">// 定义一个父类\nfunction Animal(name, sex) {\n  this.name = name;\n  this.sex = sex;\n  this.like = ['eat', 'drink', 'sleep'];\n}\n\n// 为父类的原型添加一个run方法\nAnimal.prototype.run = function() {\n  console.log('跑步');\n}\n\n// 定义一个子类\nfunction Cat(name, sex, age) {\n  // 第一次调用Animal构造函数\n  Animal.call(this, name, sex);\n  this.age = age;\n}\n\n// 核心：将Cat的原型指向父类Animal的一个实例（第二次调用Animal构造函数）\nCat.prototype = new Animal();\n\n// 实例cat.constructor是来自Cat.prototype.constructor\n// 不矫正的cat.constructor话，当前的cat.constructor指向的是Animal\n// 因为Cat.prototype被重写，constructor被指向了new Animal().__proto__.constructor，相当于Animal.prototype.constructor\nCat.prototype.constructor = Cat;\n\n// 实例一个由子类new 出来的对象\nconst cat = new Cat('limingcan', 'man', 27);\nconsole.log(cat);\n\n</code></pre>\n<p>打印：\n<img src=\"../md/js-inherit/pic_4.png\" /></p>\n<p>由上图我们能得出总结：</p>\n<ul>\n<li>\n<p>优点：</p>\n<ul>\n<li>利用原型链继承，将实例<code>cat</code>、子类<code>Cat</code>、父类<code>Animal</code>三者的原型链串联起来，让实例对象继承父类原型<code>Animal.prototype</code>的方法与属性</li>\n<li>利用借用构造函数继承，将父类构造函数<code>function Animal() {}</code>的属性、方法添加到实例<strong>自身</strong>上，解决原型链继承，实例修改引用类型属性时对后续实例影响问题</li>\n<li>利用构造函数继承，实例化对象时，可传参</li>\n</ul>\n</li>\n<li>\n<p>缺点：</p>\n<ul>\n<li>两次调用父类构造函数<code>function Animal() {}</code>（第一次在子类<code>Cat</code>构造函数内调用，第二次在<code>new Animal()</code>时候调用）</li>\n<li>实例自身拥有的属性，子类<code>Cat.prototype</code>里也会有，造成不必要的浪费（因为<code>Cat.prototype</code>被重写为<code>new Animal()</code>了，<code>new Animal()</code>是父类的一个实例，也有<code>name</code>、<code>sex</code>、<code>like</code>属性）</li>\n</ul>\n</li>\n</ul>\n<p>看来组合继承也不是最完美的继承方式。我们先把组合继承放一边，先看看什么是原型式继承。</p>\n<h3>原型式继承</h3>\n<blockquote>\n<p>原理：用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。一般使用<code>Object.create()</code>方法实现，详细用法可以看看<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\">这里</a>。</p>\n</blockquote>\n<p>来看看具体例子：</p>\n<pre><code class=\"language-javascript\">// 定义一个父类（新建出来的对象的__proto__会指向它）\nconst Animal = {\n  name: 'nobody',\n  like: ['eat', 'drink', 'sleep'],\n  run() {\n    console.log('跑步');\n  }\n};\n\n// 新建以Animal为原型的实例\nconst cat = Object.create(\n  Animal,\n  // 这里定义的是实例自身的方法或属性\n  {\n    name: {\n      value: 'limingcan'\n    }\n  }\n);\n\n// 给实例cat属性like添加一个play值\ncat.like.push('play');\n\nconst small_cat = Object.create(\n  Animal,\n  // 这里定义的是实例自身的方法或属性\n  {\n    name: {\n      value: 'mimi'\n    }\n  }\n);\n\nconsole.log(cat);\nconsole.log(small_cat);\nconsole.log(cat.__proto__ === Animal);\n\n</code></pre>\n<p>打印：\n<img src=\"../md/js-inherit/pic_5.png\" /></p>\n<p>由上图我们可以得出总结：</p>\n<ul>\n<li>\n<p>优点：</p>\n<ul>\n<li>实现比原型链继承更简洁（不需要写什么构造函数了，也不需要写子类<code>Cat</code>，直接父类继承<code>Animal</code>）</li>\n<li>子类实例可以访问到父类的属性方法</li>\n</ul>\n</li>\n<li>\n<p>缺点：</p>\n<ul>\n<li>父类所有的引用类型属性都会被实例出来的对象共享，所以修改一个实例对象的引用类型属性，会导致所有实例对象受到影响</li>\n<li>实例化时，不能传参数</li>\n</ul>\n</li>\n</ul>\n<p>我们可以对比原型链继承方式，其实这两种方式差不多，所以它要跟原型链继承存在一样的缺点，但是实现起来比原型式继承更加简洁方便一些。如果我们只是想让一个对象跟另一个对象保持类似，原型式继承可能更加舒服，因为它不需要像原型链继承那样大费周章。接下来我们再看看另一种继承方式——寄生式继承。</p>\n<h3>寄生式继承</h3>\n<blockquote>\n<p>原理：它其实就是对原型式继承进行一个小封装，增强了一下实例出来的对象</p>\n</blockquote>\n<p>来看看具体例子：</p>\n<pre><code class=\"language-javascript\">\n// 定义一个父类（新建出来的对象的__proto__会指向它）\nconst Animal = {\n  name: 'nobody',\n  like: ['eat', 'drink', 'sleep'],\n  run() {\n    console.log('跑步');\n  }\n};\n\n// 定义一个封装Object.create()方法的函数\nconst createObj = (parentPropety, ownProperty) =&gt; {\n  // 生成一个以parentPropety 为原型的对象obj\n  // ownProperty 是新建出来的实例，拥有自身的属性跟方法配置\n  const obj = Object.create(parentPropety, ownProperty);\n\n  // 增强功能\n  obj.catwalk = function() {\n    console.log('走猫步');\n  };\n\n  return obj;\n}\n\n// 新建以Animal为原型的实例一\nconst cat = createObj(Animal, {\n  name: {\n    value: 'limingcan'\n  }\n})\n\n// 给实例cat属性like添加一个play值\ncat.like.push('play');\n\n// 新建以Animal为原型的实例二\nconst small_cat = createObj(Animal, {\n  name: {\n    value: 'mimi'\n  }\n})\n\nconsole.log(cat);\nconsole.log(small_cat);\nconsole.log(cat.__proto__ === Animal);\n\n</code></pre>\n<p>打印：\n<img src=\"../md/js-inherit/pic_6.png\" /></p>\n<p>总结：</p>\n<ul>\n<li>\n<p>优点：</p>\n<ul>\n<li>实现比原型链继承更简洁</li>\n<li>子类实例可以访问到父类的属性方法</li>\n</ul>\n</li>\n<li>\n<p>缺点：</p>\n<ul>\n<li>父类所有的引用类型属性都会被实例出来的对象共享，所以修改一个实例对象的引用类型属性，会导致所有实例对象受到影响</li>\n<li>实例化时，不能传参数</li>\n</ul>\n</li>\n</ul>\n<p>寄生式继承优缺点跟原型式继承一样，但最重要的是它提供了一个类似<strong>工厂的思想</strong>，是对原型式继承的一个封装。前面我们说到组合继承还是会有一些缺陷，通过原型式继承跟寄生式继承，我们可以利用这两个继承的思想，来解决组合继承的缺陷，它就是寄生组合式继承。</p>\n<h3>寄生式组合继承</h3>\n<blockquote>\n<p>原理：利用原型链继承，实现实例对父类原型（<code>Animal.prototype</code>）方法与属性的继承；利用借用构造函数继承，实现实例对父类构造函数（<code>function Animal() {}</code>）里方法与属性的继承，并且解决了组合继承带来的缺陷</p>\n</blockquote>\n<p>前面我们说到，组合继承会有以下两个缺点：</p>\n<ul>\n<li>会两次调用父类构造函数<code>function Animal() {}</code>。（第一次在子类构造函数内使用<code>call</code>或者<code>apply</code>方法时调用；第二次在<code>Cat.prototype = new Animal()</code>时候调用了）</li>\n<li>实例自身拥有的属性，子类构造函数的<code>prototype</code>里也会有，造成不必要的浪费（因为子类构造函数的<code>protptype</code>被重写为父类的一个实例了，所以<code>Cat.prototype</code>也会拥有父类实例里的属性跟方法）</li>\n</ul>\n<p>通过上面原型式继承的方式，我们可以把原型链继承里，<code>Cat.prototype = new Animal()</code>这一步，用寄生式继承的思想，用<code>Object.create()</code>方法实现并替换掉。来看看具体例子：</p>\n<pre><code class=\"language-javascript\">// 定义一个父类\nfunction Animal(name, sex) {\n  this.name = name;\n  this.sex = sex;\n  this.like = ['eat', 'drink', 'sleep'];\n}\n\n// 定义一个子类\nfunction Cat(name, sex, age) {\n  // 第一次调用Animal构造函数\n  Animal.call(this, name, sex);\n  this.age = age;\n}\n\n// 定义一个利用原型式继承方式，跟寄生式继承思想来实现寄生组合式继承的方法\nfunction inheritObj(parentClass, childClass) {\n  // parentClass 为传入的父类\n  // childClass 为传入的子类\n  // finalProperty 为最后继承的原型对象\n\n  const finalProperty = Object.create(parentClass.prototype);\n\n  finalProperty.constructor = childClass;\n\n  childClass.prototype = finalProperty;\n}\n\n// 为父类的原型添加一个run方法\nAnimal.prototype.run = function() {\n  console.log('跑步');\n}\n\n// 实现寄生组合继承\ninheritObj(Animal, Cat);\n\n// 给子类的原型添加一个方法\nCat.prototype.catwalk = function() {\n  console.log('走猫步');\n}\n\n// 实例一个由子类new 出来的对象\nconst cat = new Cat('limingcan', 'man', 27);\n\nconsole.log(cat);\n\n</code></pre>\n<p>寄生式组合继承打印：<br>\n<img src=\"../md/js-inherit/pic_7.png\" /></p>\n<p>组合继承打印：<br>\n<img src=\"../md/js-inherit/pic_4.png\" /></p>\n<p>我们可以对比一下组合继承那张图会发现：</p>\n<ul>\n<li>实例<code>cat</code>自身该有的属性都有</li>\n<li><code>Cat.prototype</code>也干净了，没有把父类的属性都复制一遍，只有自己添加的<code>catwalk</code>方法</li>\n<li><code>Animal.prototype</code>也十分干净，只有自己添加的<code>run</code>方法</li>\n</ul>\n<p>这是基本我们最想要的结果，也是最理想的继承方式。</p>\n<p>解析：</p>\n\x3c!-- （我们把`parentClass`称作父类，把`childClass`称作子类，把`finalProperty`称作最后继承的原型对象） --\x3e\n<p>我们想想为什么在组合继承时，我们要<code>Cat.prototype = new Animal()</code>？核心是因为我们要<strong>打通实例<code>cat</code>、子类<code>Cat</code>、父类<code>Animal</code>三者的原型链</strong>，从而实现继承。我们顺着这个思路，解析一下上面<code>inheritObj</code>这个方法，短短三行，但是为什么会发生那么神奇的事：</p>\n<ul>\n<li><code>const finalProperty = Object.create(parentClass.prototype)</code>：浅拷贝一份<code>parentClass.prototype</code>，并将其作为<code>finalProperty</code>对象的原型，即<code>finalProperty.__proto__ === parentClass.prototype</code>。此时<code>finalProperty.constructor</code>指向的是<code>parentClass.prototype.constructor</code></li>\n<li><code>finalProperty.constructor = childClass</code>：寄生式继承思想，增强对象。矫正<code>finalProperty.constructor</code>，让其指向<code>childClass</code></li>\n<li><code>childClass.prototype = finalProperty</code>：使得实例找不到方法属性，会去<code>childClass.prototype</code>（<code>finalProperty</code>）里找；再找不到会去<code>finalProperty.__proto__（parentClass.prototype）</code>里找。打通了子类<code>childClass</code>与父类的<code>parentClass</code>原型链，实现了父子类的继承。</li>\n</ul>\n<p><code>inheritObj</code>方法，其实质就是下面的实现，这样可能可以更加直观的看出继承：</p>\n<pre><code class=\"language-javascript\">// 定义一个利用原型式继承方式，跟寄生式继承思想来实现寄生组合式继承的方法\nfunction inheritObj(parentClass, childClass) {\n  // parentClass 为传入的父类\n  // childClass 为传入的子类\n  \n  childClass.prototype.__proto__ = parentClass.prototype;\n\n  childClass.prototype.constructor = childClass;\n}\n</code></pre>\n<h3>最后</h3>\n<p>终于写完了！真的太累了！希望这篇文章读完对大家有所帮助，面试的时候不虚。只要理解透了各个继承方式的原理，各个继承方式的优缺点真的没有必要背，优缺点自己总结就好了呀，万变不离其宗~<br>\n如果大家有什么异同，欢迎评论交流；如果觉得这篇文章好的话，欢迎点赞分享，这篇文章真的花了我不少功夫。</p>\n"}},314:function(o,e){o.exports={attributes:{title:"如何让原生小程序支持less语法（最新教程）",des:"网上文章太老了，必须拒绝繁琐的wxss，用更爽快的less",createTime:"2022-9-13"},html:'<h2>前言</h2>\n<p>大家写小程序的时候，估计<strong>最不爽</strong>的就是写<code>wxss</code>样式了吧。维护差，可读性差，如果<code>Dom</code>嵌套的多的话，估计写下去得疯。于是上网搜了一下怎么让原生小程序支持<code>less</code>写法，但是发现很多文章都很老了，微信自己的<code>IDE</code>已经更新了<code>n</code>个版本了，文章的步骤里面已经跟<code>IDE</code>里的不一样。于是自己摸索总结了一下，本文算是<code>让原生小程序支持less语法</code>的最新版本教程了。</p>\n<blockquote>\n<h4>补充：本文使用的是<code>IDE</code>是：原生小程序自带的<code>IDE</code>，<code>vscode</code></h4>\n</blockquote>\n<h2>下载<code>Easy LESS</code>插件</h2>\n<ul>\n<li>\n<p>在<code>vscode</code>市场里面下载<code>less</code>编译插件——<code>Easy LESS</code>。安装的时候建议不要选择同步，不然的话，这个插件会同步到你别的电脑里的<code>vscode</code>。因为现在我们工程基本都用<code>webpack</code>等构建工具，可以直接编译<code>less</code>啥的，所以这个插件同步了没什么意义，下载它只是为了给原生小程序用。</p>\n<p>图示：<br>\n<img src="../md/let-miniprogram-use-less/step_1.png" width="400px" /></p>\n</li>\n<li>\n<p>比较懒的同学，也可以直接在<a href="https://pan.baidu.com/s/1s4wnhUxHeuPV_dAiNWnfYA?pwd=7777m">百度云</a>下，提取码: <code>7777</code>。这样的话，没有用<code>vscode</code>的同学，也可以直接下载插件安装。</p>\n</li>\n</ul>\n<h2>开始配置（这里跟网上的教程不一样了）</h2>\n<p>1.安装插件</p>\n<p>图示：<br>\n<img src="../md/let-miniprogram-use-less/step_2.png" width="400px" /></p>\n<ul>\n<li>\n<h4>选择“导入已安装的<code>vscode</code>扩展”方式（不建议）</h4>\n这个方式不太建议。因为这种方式，会将你<code>vscode</code>里面<strong>安装过的</strong>插件，都装到原生小程序<code>IDE</code>里面。但是有很多插件，实际上在原生小程序<code>IDE</code>里是用不到也用不了的，比如：<code>Live Server</code>、<code>Vetur</code>、<code>open in browser</code>等。个人喜欢<code>IDE</code>里能不装的东西，绝对不装。</li>\n<li>\n<h4>选择“从已解包的扩展文件夹安装”方式（建议）</h4>\n这个方式强烈建议。算是一种按需载入，需要什么就加什么，很符合“编程思想”。<br>\n如果是在<code>vscode</code>上面下载的，则找到<code>vscode</code>里面插件的路径：\n<ul>\n<li><code>windows</code>路径：<code>C:\\Users\\Administrator\\.vscode\\extensions</code></li>\n<li><code>Mac</code>路径：<code>User/（你的用户名）/.vscode/extensions</code>（打开<code>Finder</code>，转到<code>Macintosh HD</code>文件夹（从左栏中的设备访问），按住<code>Cmd + Shift + . </code>所有隐藏文件都将变为可见）</li>\n</ul>\n</li>\n</ul>\n<p>2.配置插件相关的配置信息<br>\n<code>ctr + p</code>，输入<code>&gt;setting.json</code>，选择打开<code>首选项：打开设置（json）</code>，拉到最下面，加入配置：</p>\n<pre><code class="language-javascript">&quot;less.compile&quot;: {\n    &quot;outExt&quot;: &quot;.wxss&quot;\n},\n</code></pre>\n<p>如果成功配置的话，上面那几行代码是会高亮的，如果没有高亮，说明没有配置成功</p>\n<h2>验证</h2>\n<p>上面的步骤都完成了以后，重启一下<code>IDE</code>，输入新建一个<code>less</code>文件测试一下，如果<code>ctr + s</code>可以输出一个<code>.wxss</code>的文件，则说明所有配置成功了，以下为成功示例：</p>\n  <img src="../md/let-miniprogram-use-less/step_3.png" width="400px" />  \n<p><code>PS</code>：在所有步骤完成后，有时可能会出现<code>ctr + s</code> 不能输出<code>.wxss</code>文件的情况，这时可以更新小程序自带的<code>IDE</code>试试。</p>\n<h2>完美<code>Ending</code></h2>\n<p>其实完成以上步骤，基本就可以了。但是为了更完美一点，我们还需要再加多一个忽略上传文件的配置。<br>\n发布体验小程序的时候，大家都知道包是有大小限制的，所以当我们的页面越多，<code>.less</code>文件也会越多，这多多少少会增加我们进入小程序时耗得时间。所以我们在发布预览小程序的时候，要忽略掉<code>.less</code>文件的上传（测试好像实际不会上传<code>.less</code>，但为了保险起见，还是加上忽略配置）。打开根目录的<code>project.config.json</code>文件，加入以下配置：</p>\n<pre><code class="language-javascript">&quot;packOptions&quot;: {\n    &quot;ignore&quot;: [\n    {\n        &quot;value&quot;: &quot;.less&quot;,\n        &quot;type&quot;: &quot;suffix&quot;\n    },\n},\n</code></pre>\n<p>关于<code>project.config.json</code>文件相关介绍，大家可以去<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html#%E4%B8%80%E7%BA%A7%E5%AD%97%E6%AE%B5">官方文档</a>详细看看</p>\n'}}}]);