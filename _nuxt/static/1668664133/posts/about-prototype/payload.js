__NUXT_JSONP__("/posts/about-prototype", {data:[{posts:{attributes:{title:"带你搞明白到底什么是原型、原型链",des:"__proto__、prototype、constructor到底是什么？带你一步步搞明白",createTime:"2022-3-14"},html:"\u003Ch2\u003E带你搞明白到底什么是原型、原型链\u003C\u002Fh2\u003E\n\u003Ch3\u003E前言\u003C\u002Fh3\u003E\n\u003Cp\u003E首先原型、原型链，算是前端进阶里面必不可少，十分重要的一块了。在面试，面试官很喜欢用这一块来辨别你的底层知识掌握的怎么样；用的第三方框架，库里面，很多功能模块化了，但大部分功能都继承自一个基类，所以了解原型、原型链对我们使用第三方的框架、库也有着很大的帮助。\u003C\u002Fp\u003E\n\u003Ch3\u003E理解什么是\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E、\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003E很多人在看这一块知识的时候，刚开头看可能还能理解，看久了就懵了，那是因为代码中充斥着各种\u003Ccode\u003Ex.__proto__.__proto__\u003C\u002Fcode\u003E，\u003Ccode\u003Ex.__proto__.constructor.prototype\u003C\u002Fcode\u003E，\u003Ccode\u003Ex.prototype.__proto__\u003C\u002Fcode\u003E，这当然会懵掉。所以我们要理解原型、原型链是什么，一定要先搞明白，\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E、\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E是什么东西。\u003Cbr\u003E\n下面笔者会比较用通俗的话来解释，带着大家更好的理解原型，原型链是什么（因为为了大家更好的理解，所以有些地方可能会稍微有点不恰当，敬请见谅）。\u003C\u002Fp\u003E\n\u003Ch4\u003E\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E：\u003C\u002Fh4\u003E\n\u003Cp\u003E这个属性可以通俗的理解成，\u003Cstrong\u003E所有对象拥都有的属性（函数也是一种特殊的对象，所以构造函数也会有这个属性）\u003C\u002Fstrong\u003E。所以\u003Cstrong\u003E实例出来的对象，构造函数都会有\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E这个属性\u003C\u002Fstrong\u003E。它最后一定\u003Cstrong\u003E指向某个构造函数的原型（\u003Ccode\u003Ex.prototype\u003C\u002Fcode\u003E）\u003C\u002Fstrong\u003E。因此，当我们看到最后结尾如果是\u003Ccode\u003E.__proto__\u003C\u002Fcode\u003E，那它的返回值一定是\u003Ccode\u003Ex.prototype\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E但只有一个例外，那就是\u003Ccode\u003EObeject.prototype.__proto__\u003C\u002Fcode\u003E，它的末端是\u003Ccode\u003Enull\u003C\u002Fcode\u003E，所以我们看到\u003Ccode\u003E.__proto__\u003C\u002Fcode\u003E结尾时，一定要判断好前面是不是\u003Ccode\u003EObeject.prototype\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E因此我们可以总结\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E以下特点：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E对象都拥有的属性，构造函数也有\u003C\u002Fli\u003E\n\u003Cli\u003E最后一定指向某个构造函数的\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E（\u003Ccode\u003Ex.prototype\u003C\u002Fcode\u003E）\u003C\u002Fli\u003E\n\u003Cli\u003E只有一个例外，\u003Ccode\u003EObeject.prototype.__proto__\u003C\u002Fcode\u003E指向的是\u003Ccode\u003Enull\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E构造函数的\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E都直接指向\u003Ccode\u003EFunction.prototype\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4\u003E\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E：\u003C\u002Fh4\u003E\n\u003Cp\u003E这个属性可以通俗的理解成，只有构造函数才会拥有的属性，实例出来的对象，是不会有这个属性的。\u003C\u002Fp\u003E\n\u003Cp\u003E因此我们可以总结\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E以下特点：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E构造函数独有的属性\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4\u003E\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E：\u003C\u002Fh4\u003E\n\u003Cp\u003E这个属性存在于两个地方\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E构造函数的原型对象（\u003Ccode\u003Ex.prototype\u003C\u002Fcode\u003E）\u003C\u002Fli\u003E\n\u003Cli\u003E构造函数本身也有（继承自\u003Ccode\u003EFunction.prototype.constructor\u003C\u002Fcode\u003E）\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E实例出来的对象也可以访问到\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E，是因为实例出来的对象\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E继承自构造函数的原型对象（\u003Ccode\u003Ex.prototype\u003C\u002Fcode\u003E），可以用\u003Ccode\u003EhasOwnProperty('constructor')\u003C\u002Fcode\u003E验证\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E验证：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Efunction Person() {\n\n}\nvar lMC = new Person();\nconsole.log(lMC.constructor.name);  \u002F\u002F Person\nconsole.log(lMC.hasOwnProperty('constructor'));  \u002F\u002F false\nconsole.log(Person.prototype.constructor.name);  \u002F\u002F Person\nconsole.log(Person.prototype.hasOwnProperty('constructor'));  \u002F\u002F true\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E因此我们可以总结\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E以下特点：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E构造函数的原型对象（\u003Ccode\u003Ex.prototype\u003C\u002Fcode\u003E）拥有的属性，指回构造函数本身\u003C\u002Fli\u003E\n\u003Cli\u003E构造函数本身也有，指向\u003Ccode\u003EFunction\u003C\u002Fcode\u003E；\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4\u003E什么是原型链\u003C\u002Fh4\u003E\n\u003Cp\u003E当我们用构造函数\u003Ccode\u003EFunc\u003C\u002Fcode\u003E实例化了一个对象\u003Ccode\u003EA\u003C\u002Fcode\u003E后，访问\u003Ccode\u003EA\u003C\u002Fcode\u003E的方法或者属性时，会现在\u003Ccode\u003EA\u003C\u002Fcode\u003E自身找有没有对应的方法属性，没有的话则通过\u003Ccode\u003EA.__proto__\u003C\u002Fcode\u003E去构造函数的原型对象\u003Ccode\u003EFunc.prototype\u003C\u002Fcode\u003E找，如果\u003Ccode\u003EFunc.prototype\u003C\u002Fcode\u003E也没有，则在往\u003Ccode\u003EFunc.prototype.__proto__\u003C\u002Fcode\u003E往\u003Ccode\u003EObeject.prototype\u003C\u002Fcode\u003E找，如果还没有则再通过\u003Ccode\u003EObeject.prototype.__proto__\u003C\u002Fcode\u003E找，在这过程中，如果有则返回相应的方法属性，没有的话则再通过\u003Ccode\u003EObeject.prototype.__proto__\u003C\u002Fcode\u003E找，但此时\u003Ccode\u003EObeject.prototype.__proto__\u003C\u002Fcode\u003E已经到顶，指向的是\u003Ccode\u003Enull\u003C\u002Fcode\u003E，所以此时没有对应的方法属性，返回\u003Ccode\u003Eundefined\u003C\u002Fcode\u003E。\u003Cbr\u003E\n在查找的过程中会遍历以上的一条链，这条链就是原型链：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"..\u002Fmd\u002Fabout-prototype\u002Fpic_1.png\" alt=\"原型链1\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E等同于\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"..\u002Fmd\u002Fabout-prototype\u002Fpic_2.png\" alt=\"原型链2\"\u003E\u003C\u002Fp\u003E\n\u003Ch3\u003E方法总结\u003C\u002Fh3\u003E\n\u003Cp\u003E假定我们用\u003Ccode\u003EFunc\u003C\u002Fcode\u003E表示构造函数；\u003Ccode\u003Eobj\u003C\u002Fcode\u003E表示\u003Ccode\u003EFunc\u003C\u002Fcode\u003E的实例对象\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\n\u003Cp\u003E如果最后以\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E结尾，返回的一定是\u003Ccode\u003Ex.prototype\u003C\u002Fcode\u003E（\u003Ccode\u003EObject.prototype.__proto__\u003C\u002Fcode\u003E除外），所以我们先确定是\u003Cstrong\u003E谁的\u003C\u002Fstrong\u003E\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E如果是\u003Ccode\u003EFunc\u003C\u002Fcode\u003E的\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E，那么直接指向\u003Ccode\u003EFunction.prototype\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E如果是\u003Ccode\u003Eobj\u003C\u002Fcode\u003E的\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E，那么直接指向其实例的构造函数的\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E(\u003Ccode\u003EFunc.prototype\u003C\u002Fcode\u003E)\u003C\u002Fli\u003E\n\u003Cli\u003E如果是\u003Ccode\u003EFunc.prototype\u003C\u002Fcode\u003E的\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E，那么直接指向\u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E，（因为\u003Ccode\u003EFunc.prototype\u003C\u002Fcode\u003E是对象，其构造函数是\u003Ccode\u003EObject\u003C\u002Fcode\u003E）\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E如果是以\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E结尾，只用判断是\u003Cstrong\u003E谁的\u003C\u002Fstrong\u003E\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E，只有构造函数才有\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E属性\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Eobj.prototype\u003C\u002Fcode\u003E，返回\u003Ccode\u003Eundefined\u003C\u002Fcode\u003E，因为\u003Ccode\u003Eobj\u003C\u002Fcode\u003E是实例，不是构造函数\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EFunc.prototype\u003C\u002Fcode\u003E，返回\u003Ccode\u003EFunc\u003C\u002Fcode\u003E这个构造函数的\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E所有内容\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E如果是以\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E结尾，先弄清楚前面是\u003Cstrong\u003E对象\u003C\u002Fstrong\u003E、\u003Cstrong\u003E构造函数\u003C\u002Fstrong\u003E、还是\u003Cstrong\u003E构造函数.prototype的constructor\u003C\u002Fstrong\u003E；\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E如果是\u003Cstrong\u003E构造函数\u003C\u002Fstrong\u003E的\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E，则直接指向\u003Ccode\u003EFunction\u003C\u002Fcode\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003EFunc.constructor\u003C\u002Fcode\u003E，直接指向\u003Ccode\u003EFunction\u003C\u002Fcode\u003E，因为构造函数的构造器，当然是\u003Ccode\u003EFunction\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E如果是\u003Cstrong\u003E对象\u003C\u002Fstrong\u003E的\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E：\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Eobj.constructor\u003C\u002Fcode\u003E，直接指向\u003Ccode\u003EFunc\u003C\u002Fcode\u003E，因为\u003Ccode\u003Eobj\u003C\u002Fcode\u003E是由\u003Ccode\u003EFunc\u003C\u002Fcode\u003E构造而来，所以当然是\u003Ccode\u003EFunc\u003C\u002Fcode\u003E（\u003Ccode\u003Eobj.constructor\u003C\u002Fcode\u003E实际上是继承自\u003Ccode\u003EFunc.prototype.constructor\u003C\u002Fcode\u003E，\u003Ccode\u003Eobj\u003C\u002Fcode\u003E本身是没有\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E的）\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E如果是构造函数.prototype的constructor\u003Cstrong\u003E始终指回为这个构造函数\u003C\u002Fstrong\u003E，所以：\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E\u003Ccode\u003EFunc.prototype.constructor\u003C\u002Fcode\u003E，指回\u003Ccode\u003EFunc\u003C\u002Fcode\u003E本身\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E\u003Ccode\u003EObject.prototype.constructor\u003C\u002Fcode\u003E，指回\u003Ccode\u003EObeject\u003C\u002Fcode\u003E构造函数\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E\u003Ccode\u003EFuction.prototype.constructor\u003C\u002Fcode\u003E，指回\u003Ccode\u003EFuction\u003C\u002Fcode\u003E构造函数\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E\u003Ccode\u003EObeject.constructor\u003C\u002Fcode\u003E，指向\u003Ccode\u003EFunction\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3\u003E牛刀小试\u003C\u002Fh3\u003E\n\u003Cp\u003E根据上面对\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E、\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E的特点总结，还有方法总结，我们可以拿下面这道题来试试，如果大家都可以正确无误的答出来，那大家对原型应该就了解的差不多了\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Efunction Person(name) {\n    this.name = name\n}\nvar p2 = new Person('king');\n\nconsole.log(p2.__proto__); \u002F\u002F Person.prototype\n\nconsole.log(p2.__proto__.__proto__); \u002F\u002F Object.prototype\n\nconsole.log(p2.__proto__.__proto__.__proto__); \u002F\u002F null\n\nconsole.log(p2.__proto__.__proto__.__proto__.__proto__.__proto__); \u002F\u002F 报错\n\nconsole.log(p2.constructor); \u002F\u002F Person\n\nconsole.log(p2.prototype); \u002F\u002F undefined\n\nconsole.log(Person.constructor); \u002F\u002F Function\n\nconsole.log(Person.prototype); \u002F\u002F 输出Person.prototype这个对象里所有的方法和属性\n\nconsole.log(Person.prototype.constructor); \u002F\u002F Person\n\nconsole.log(Person.prototype.__proto__); \u002F\u002F Obejct.prototype\n\nconsole.log(Person.__proto__); \u002F\u002F Fuction.prototype\n\nconsole.log(Function.prototype.__proto__); \u002F\u002F Obeject.prototype\n\nconsole.log(Function.__proto__); \u002F\u002F Function.prototype\n\nconsole.log(Object.__proto__); \u002F\u002F Function.prototype\n\nconsole.log(Object.prototype.__proto__); \u002F\u002F null\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3\u003E最后\u003C\u002Fh3\u003E\n\u003Cp\u003E原型、原型链本来就挺绕的，所以建议大家先了解\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E之间的链接，熟悉了，再把\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E加上一起理解，循环渐进。等理解以后，多画几遍原型链图加深理解。OK，最后假定我们用\u003Ccode\u003EAnimal\u003C\u002Fcode\u003E表示构造函数；\u003Ccode\u003Edog\u003C\u002Fcode\u003E表示\u003Ccode\u003EAnimal\u003C\u002Fcode\u003E的实例对象，祭出一张原型链图：\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cstrong\u003E红色链表示的是我们平时实例出来的对象的原型链\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E\u003Cimg src=\"..\u002Fmd\u002Fabout-prototype\u002Fpic_3.png\" alt=\"原型链图\"\u003E\u003C\u002Fp\u003E\n"}}],fetch:{},mutations:[]});