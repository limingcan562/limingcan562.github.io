__NUXT_JSONP__("/posts/know-babel", {data:[{posts:{attributes:{title:"想弄懂Babel？你必须得先弄清楚这几个包",des:"学习Babel 7，看懂官方文档，梳理、了解，我们平时接触Babel用到的主要几个包，搞清楚Babel是什么、作用又是什么",createTime:"2023-1-19"},html:"\u003Ch2\u003E前言\u003C\u002Fh2\u003E\n\u003Cp\u003E相信很多人都知道\u003Ccode\u003EBabel\u003C\u002Fcode\u003E，知道它是用来编译\u003Ccode\u003EES6+\u003C\u002Fcode\u003E的东西。但是再深入一点，大家都清楚我们平时项目中\u003Ccode\u003EBabel\u003C\u002Fcode\u003E用到的那些包作用是什么吗？为什么要用那几个包？\u003C\u002Fp\u003E\n\u003Cp\u003E另外，我们平时项目中\u003Ccode\u003EBabel\u003C\u002Fcode\u003E用到的包其实并不多，基本就是文章中讲解的这几个包，所以如果大家能把这几个包弄得很清楚，\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的大部分知识也了解的差不多了。\u003C\u002Fp\u003E\n\u003Cp\u003E由于\u003Ccode\u003EBabel\u003C\u002Fcode\u003E内容实在太多，加上配置讲的话，篇幅太长，大家阅读也累。为了让大家更好地理解，我们把\u003Ccode\u003EBabel\u003C\u002Fcode\u003E拆成两部分（\u003Ccode\u003EBabel\u003C\u002Fcode\u003E了解篇，\u003Ccode\u003EBabel\u003C\u002Fcode\u003E配置篇）来学习：\u003C\u002Fp\u003E\n\u003Ch3\u003E\u003Ccode\u003EBabel\u003C\u002Fcode\u003E了解篇\u003C\u002Fh3\u003E\n\u003Cp\u003E就是本篇文章。脱离配置\u003Ccode\u003EBabel\u003C\u002Fcode\u003E这块，系统的梳理、介绍、讲解我们平时\u003Ccode\u003EBabel\u003C\u002Fcode\u003E用到的主要几个包。\u003C\u002Fp\u003E\n\u003Ch3\u003E\u003Ccode\u003EBabel\u003C\u002Fcode\u003E配置篇\u003C\u002Fh3\u003E\n\u003Cp\u003E当我们在清楚地理解了\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的主要几个包后，我们就能更好地深入\u003Ccode\u003EBabel\u003C\u002Fcode\u003E怎么配置。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E注意：本篇文章不涉及\u003Ccode\u003EBabel\u003C\u002Fcode\u003E配置篇，后续会专门出文章讲解怎么配置\u003Ccode\u003EBabel\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E本篇文章稍微有点长，第一是因为\u003Ccode\u003EBabel\u003C\u002Fcode\u003E本身内容就特别多，第二是因为有些同学看官网的时候，觉得很难懂，所以文章写的比较详细，并且会答疑了一些我们平时看官网难懂的地方，所以希望大家可以静下心来，一个模块一个模块的看，每个模块都是循序渐进的。相信我，看完你一定会对\u003Ccode\u003EBabel\u003C\u002Fcode\u003E有一个\u003Cstrong\u003E更清晰的理解\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E章节中的案例，代码都放到 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\"\u003EGithub\u003C\u002Fa\u003E 上了，建议大家边阅读，边跟着案例看。如果大家觉得有帮助到，欢迎\u003Cstrong\u003EStar\u003C\u002Fstrong\u003E 跟 \u003Cstrong\u003EFork\u003C\u002Fstrong\u003E学习。\u003C\u002Fp\u003E\n\u003Cp\u003E备注：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E当前\u003Ccode\u003E@babel\u002Fcore\u003C\u002Fcode\u003E最新版本是：\u003Ccode\u003E7.20.12\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E当前\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E最新版本是：\u003Ccode\u003E7.20.2\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003E\u003Ccode\u003EBabel\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E官网解释：\u003Ccode\u003EBabel\u003C\u002Fcode\u003E是一个工具链，主要用于将采用\u003Ccode\u003EECMAScript 2015+\u003C\u002Fcode\u003E语法编写的代码转换为向后兼容的 \u003Ccode\u003EJavaScript\u003C\u002Fcode\u003E语法，以便能够运行在当前和旧版本的浏览器或其他环境中。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E我们可以这么理解，\u003Ccode\u003EBabel\u003C\u002Fcode\u003E就是一个工具。它是一个可以将\u003Ccode\u003EES6+\u003C\u002Fcode\u003E等新特性，转换成低版本浏览器或其他环境能支持并正常运行的一个工具。\u003C\u002Fp\u003E\n\u003Ch3\u003E结构\u003C\u002Fh3\u003E\n\u003Cp\u003E很多人以为\u003Ccode\u003EBabel\u003C\u002Fcode\u003E只有\u003Ccode\u003Eplugins\u003C\u002Fcode\u003E、\u003Ccode\u003Epresets\u003C\u002Fcode\u003E等几个配置。其实不止，我们看看\u003Ccode\u003EBabel\u003C\u002Fcode\u003E配置文件大致架构：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F babel.config.js\nmodule.exports = {\n    ...,\n    envName: &quot;development&quot;,\n    plugins: [],\n    presets: [],\n    passPerPreset: false,\n    targets: {},\n    browserslistConfigFile: true,\n    browserslistEnv: undefined,\n    inputSourceMap: true\n    ...\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E我们一般主要用到的就是\u003Ccode\u003Eplugins\u003C\u002Fcode\u003E、\u003Ccode\u003Epresets\u003C\u002Fcode\u003E这两个\u003C\u002Fp\u003E\n\u003Ch3\u003E功能\u003C\u002Fh3\u003E\n\u003Cp\u003E从大体上看，\u003Ccode\u003EBabel\u003C\u002Fcode\u003E提供以下两个功能组成：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E编译\u003Ccode\u003EES6+\u003C\u002Fcode\u003E最新语法（\u003Ccode\u003Elet\u003C\u002Fcode\u003E、\u003Ccode\u003Eclass\u003C\u002Fcode\u003E、\u003Ccode\u003E() =&gt; {}\u003C\u002Fcode\u003E等）\u003C\u002Fli\u003E\n\u003Cli\u003E实现旧版本浏览器不支持的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E（\u003Ccode\u003EPromise\u003C\u002Fcode\u003E、\u003Ccode\u003ESymbol\u003C\u002Fcode\u003E、\u003Ccode\u003EArray.prototype.includes\u003C\u002Fcode\u003E等）\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E参考文章：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002F\"\u003EWhat is Babel?\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.babeljs.cn\u002Fdocs\u002Foptions\"\u003EOptions\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003E\u003Ccode\u003E@babel\u002Fcore\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003E从\u003Ccode\u003Ecore\u003C\u002Fcode\u003E可以看出，它是\u003Ccode\u003EBabel\u003C\u002Fcode\u003E实现编译的核心。所以我们如果要使用\u003Ccode\u003EBabel\u003C\u002Fcode\u003E，\u003Ccode\u003E@babel\u002Fcore\u003C\u002Fcode\u003E这个包一定是必不可少的。另外我们平常说的\u003Ccode\u003EBabel 6\u003C\u002Fcode\u003E、\u003Ccode\u003EBabel 7\u003C\u002Fcode\u003E指的就是\u003Ccode\u003E@babele\u002Fcore\u003C\u002Fcode\u003E的版本\u003C\u002Fp\u003E\n\u003Cp\u003E参考文章：\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fbabel-core\"\u003E@babel\u002Fcore\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch2\u003E\u003Ccode\u003E@bable\u002Fcli\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E官网解释：\u003Ccode\u003EBabel\u003C\u002Fcode\u003E自带了一个内置的\u003Ccode\u003ECLI\u003C\u002Fcode\u003E命令行工具，可通过命令行编译文件\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E简单地说就是，让我们可以在\u003Cstrong\u003E终端\u003C\u002Fstrong\u003E里使用命令来编译（这样可以更好的调试打印信息）：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003Enpx babel index.js\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E安装的话，我们最好安装到我们项目的本地目录下，尽量不要安装到全局（影响全局的东西，都很可怕）\u003C\u002Fp\u003E\n\u003Cp\u003E参考文章：\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fbabel-cli\"\u003E\u003Ccode\u003E@babel\u002Fcli\u003C\u002Fcode\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch2\u003E\u003Ccode\u003E@bable\u002Fpreset-env\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E官网解释：\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E是一个智能预设，它允许您使用最新的\u003Ccode\u003EJavaScript\u003C\u002Fcode\u003E，而无需微观管理目标环境需要哪些语法转换（以及可选的浏览器\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E）。这既让你的生活更轻松，也让\u003Ccode\u003EJavaScript\u003C\u002Fcode\u003E包更小！\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch3\u003E理解\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Ccode\u003E@bable\u002Fpreset-env\u003C\u002Fcode\u003E这个名字，我们可以拆开两部分来看，这样方便理解：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Epreset\u003C\u002Fcode\u003E预设\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eenv\u003C\u002Fcode\u003E环境\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4\u003E\u003Ccode\u003Epreset\u003C\u002Fcode\u003E\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Ccode\u003EBabel\u003C\u002Fcode\u003E编译\u003Ccode\u003EES6+\u003C\u002Fcode\u003E\u003Cstrong\u003E语法\u003C\u002Fstrong\u003E，是通过一个个插件\u003Ccode\u003Eplugin\u003C\u002Fcode\u003E去实现的。每年都会有不同新的提案、新的语法，但我们不可能一个个插件去配置，所以就有了\u003Ccode\u003Epreset\u003C\u002Fcode\u003E这个东西。因此我们可以理解成\u003Ccode\u003Epreset\u003C\u002Fcode\u003E就是一个\u003Cstrong\u003E语法插件集合包\u003C\u002Fstrong\u003E，这样我们只用安装这一个包，不需要一个个配插件，就可以很方便的编译最新的语法了。\u003C\u002Fp\u003E\n\u003Cp\u003E我们通过一个不用预设的案例 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fno-preset\"\u003Eno-preset\u003C\u002Fa\u003E ，感受一下如果不用\u003Ccode\u003Epreset\u003C\u002Fcode\u003E有多麻烦。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F  入口文件 index.js\nconst senses = ['eye', 'nose', 'ear', 'mouth'];\n\nconst lMC = {\n    senses,\n    like: ['eat', 'drink', 'play', 'fun'],\n    information: {\n        sex: 'male',\n        age: '18+'\n    },\n    play: (sport = 'badminton') =&gt; {\n        console.log(`play ${sport}`);\n    }\n};\n\nconst { like, information } = lMC;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这段代码，我们用了几个\u003Ccode\u003EES6\u003C\u002Fcode\u003E新语法：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Econst\u003C\u002Fcode\u003E声明\u003C\u002Fli\u003E\n\u003Cli\u003E属性的简洁表示法\u003C\u002Fli\u003E\n\u003Cli\u003E箭头函数\u003C\u002Fli\u003E\n\u003Cli\u003E函数默认值\u003C\u002Fli\u003E\n\u003Cli\u003E模板字符串\u003C\u002Fli\u003E\n\u003Cli\u003E解构\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E如果不用\u003Ccode\u003Epreset\u003C\u002Fcode\u003E我们\u003Ccode\u003EBabel\u003C\u002Fcode\u003E配置如下：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F Babel配置文件 babel.config.js\nconst plugins = [\n    '@babel\u002Fplugin-transform-arrow-functions',\n    '@babel\u002Fplugin-transform-block-scoping',\n    '@babel\u002Fplugin-transform-destructuring',\n    '@babel\u002Fplugin-transform-parameters',\n    '@babel\u002Fplugin-transform-shorthand-properties',\n    '@babel\u002Fplugin-transform-template-literals'\n];\nmodule.exports = {plugins};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E编译后的文件：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F 编译后的文件 compile.js\nvar senses = ['eye', 'nose', 'ear', 'mouth'];\nvar lMC = {\n  senses: senses,\n  like: ['eat', 'drink', 'play', 'fun'],\n  information: {\n    sex: 'male',\n    age: '18+'\n  },\n  play: function () {\n    var sport = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : 'badminton';\n    console.log(&quot;play &quot;.concat(sport));\n  }\n};\nvar like = lMC.like,\n  information = lMC.information;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在不用\u003Ccode\u003Epreset\u003C\u002Fcode\u003E的情况下，实现上述编译的过程，我基本是用一个\u003Ccode\u003EES6\u003C\u002Fcode\u003E新语法，我就要去查一个插件，首先我不记得那么多插件，其次一个个插件找真的很累。\u003C\u002Fp\u003E\n\u003Cp\u003Eok，那我们再用一个使用了预设的案例 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fuse-preset\"\u003Euse-preset\u003C\u002Fa\u003E ，感受一下预设到底有多方便。\n我们\u003Ccode\u003Enpm i @babel\u002Fpreset-env -D\u003C\u002Fcode\u003E，修改\u003Ccode\u003Ebabel.config.js\u003C\u002Fcode\u003E使用\u003Ccode\u003Epreset\u003C\u002Fcode\u003E预设：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F 修改babel.config.js\nconst presets = [\n    '@babel\u002Fpreset-env'\n];\n\nmodule.exports = {presets};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E编译后的文件：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F 编译后的文件 compile.js\n&quot;use strict&quot;;\n\nvar senses = ['eye', 'nose', 'ear', 'mouth'];\nvar lMC = {\n  senses: senses,\n  like: ['eat', 'drink', 'play', 'fun'],\n  information: {\n    sex: 'male',\n    age: '18+'\n  },\n  play: function play() {\n    var sport = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : 'badminton';\n    console.log(&quot;play &quot;.concat(sport));\n  }\n};\nvar like = lMC.like,\n  information = lMC.information;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E我们会发现，用\u003Ccode\u003Epreset\u003C\u002Fcode\u003E（预设）方式输出的代码，跟\u003Ccode\u003Eplugins\u003C\u002Fcode\u003E（不用预设）方式输出的代码是几乎是一模一样的。但是\u003Ccode\u003Epreset\u003C\u002Fcode\u003E的\u003Ccode\u003Ebabel.config.js\u003C\u002Fcode\u003E更简洁，我也不需要一个个插件去找，也不需要安装那么多插件，只用安装\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E这一个包，就可以很愉快的写\u003Ccode\u003EES6+\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Ch4\u003E\u003Ccode\u003Eenv\u003C\u002Fcode\u003E\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Ccode\u003Eenv\u003C\u002Fcode\u003E指的是环境。因为\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E还有一个配置功能，我们可以通过配置我们代码运行的\u003Cstrong\u003E目标环境\u003C\u002Fstrong\u003E，来控制\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E（一个提供低版本浏览器缺失的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E新特性的方法与实现的集合 ，后面会有更详细的讲解）的导入跟语法编译，从而使\u003Ccode\u003EES6+\u003C\u002Fcode\u003E新的特性可以在我们想要的\u003Cstrong\u003E目标环境\u003C\u002Fstrong\u003E中顺利运行。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E备注：\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E的配置功能，后续会有文章说明\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch3\u003E功能\u003C\u002Fh3\u003E\n\u003Cp\u003E通过上面对\u003Ccode\u003Epreset\u003C\u002Fcode\u003E、\u003Ccode\u003Eenv\u003C\u002Fcode\u003E的理解跟案例感受，我们能总结出\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E主要提供以下功能：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E它\u003Cstrong\u003E只编译\u003Ccode\u003EES6+\u003C\u002Fcode\u003E语法\u003C\u002Fstrong\u003E（上述案例只使用了\u003Ccode\u003EES6+\u003C\u002Fcode\u003E的语法，并没有用\u003Ccode\u003EES6+\u003C\u002Fcode\u003E的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E）\u003C\u002Fli\u003E\n\u003Cli\u003E它并不提供\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E，但是可以通过\u003Cstrong\u003E配置\u003C\u002Fstrong\u003E我们代码运行的\u003Cstrong\u003E目标环境\u003C\u002Fstrong\u003E，从而控制\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E的导入跟语法编译，使\u003Ccode\u003EES6+\u003C\u002Fcode\u003E的新特性可以在我们想要的\u003Cstrong\u003E目标环境\u003C\u002Fstrong\u003E中顺利运行\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3\u003E注意\u003C\u002Fh3\u003E\n\u003Cp\u003E我们先看看\u003Ccode\u003ETC39\u003C\u002Fcode\u003E提案分为几个阶段：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E阶段0　 （\u003Ccode\u003Estage-0\u003C\u002Fcode\u003E）——草根（Strawman）：只是一个想法，可能是\u003Ccode\u003EBabel\u003C\u002Fcode\u003E插件。\u003C\u002Fli\u003E\n\u003Cli\u003E第一阶段（\u003Ccode\u003Estage-1\u003C\u002Fcode\u003E）——提案（Proposal）：这是值得研究的。\u003C\u002Fli\u003E\n\u003Cli\u003E第二阶段（\u003Ccode\u003Estage-2\u003C\u002Fcode\u003E）——草案（Draft）：初步规范。\u003C\u002Fli\u003E\n\u003Cli\u003E第三阶段（\u003Ccode\u003Estage-3\u003C\u002Fcode\u003E）——候选（Candidate）：完整的规范和最初的浏览器实现。\u003C\u002Fli\u003E\n\u003Cli\u003E第四阶段（\u003Ccode\u003Estage-4\u003C\u002Fcode\u003E）——完成（Finished）：将被添加到下一年度的版本中。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E再看看官网中这段话：\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003ENote: \u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E won't include any JavaScript syntax proposals less than Stage 3 because at that stage in the TC39 process, it wouldn't be implemented by any browsers anyway. Those would need to be included manually.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E大致意思是：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E在\u003Ccode\u003EBabel 7\u003C\u002Fcode\u003E以后，\u003Ccode\u003E@bable\u002Fpreset-env\u003C\u002Fcode\u003E舍弃了\u003Ccode\u003EStage presets\u003C\u002Fcode\u003E（\u003Ccode\u003E@babel\u002Fpreset-stage-x\u003C\u002Fcode\u003E）这种预设\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E@bable\u002Fpreset-env\u003C\u002Fcode\u003E只提供\u003Ccode\u003ETC39\u003C\u002Fcode\u003E大于\u003Ccode\u003Estage-3\u003C\u002Fcode\u003E的提案（即只包含\u003Ccode\u003Estage-4\u003C\u002Fcode\u003E阶段），因此如果要用小于\u003Ccode\u003Estage 4\u003C\u002Fcode\u003E的提案语法，则必须先安装再手动引入对应插件\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E第一点相信大家都很好理解，我们来理解一下第二点是什么意思。\u003C\u002Fp\u003E\n\u003Cp\u003E意思是，如果我们想用一些小于\u003Ccode\u003Estage-4\u003C\u002Fcode\u003E阶段的语法的话，光安装\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E这一个包是没有用的，因为这个包里只包含编译\u003Ccode\u003Estage-4\u003C\u002Fcode\u003E的预设，所以我们就得安装并配置相应的\u003Ccode\u003Eplugin\u003C\u002Fcode\u003E去编译。\u003C\u002Fp\u003E\n\u003Cp\u003E在写这篇文章的时候，有一个新的语法 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ftc39\u002Fproposal-do-expressions\"\u003Edo expressions\u003C\u002Fa\u003E ，它当前是处于\u003Ccode\u003Estage-1\u003C\u002Fcode\u003E阶段的语法，用插件\u003Ccode\u003E@babel\u002Fplugin-proposal-do-expressions\u003C\u002Fcode\u003E可以编译这个语法。\u003C\u002Fp\u003E\n\u003Cimg src=\"..\u002Fmd\u002Fknow-babel\u002Fcompole-stage-1-1.jpeg\" alt=\"pic.jpeg\" width=\"100%\"\u002F\u003E  \n\u003Cblockquote\u003E\n\u003Cp\u003E官网解释：do { .. } 表达式执行一个块（其中有一个或多个语句），块内的最终语句完成值成为 do 表达式的完成值。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E我们借助\u003Ca href=\"https:\u002F\u002Fwww.babeljs.cn\u002Fdocs\u002Fbabel-plugin-proposal-do-expressions\"\u003E官网\u003C\u002Fa\u003E，整理成这个案例 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fcompile-stage-1\"\u003Ecompile-stage-1\u003C\u002Fa\u003E 来看看怎么使用小于\u003Ccode\u003Estage-4\u003C\u002Fcode\u003E的语法。\u003C\u002Fp\u003E\n\u003Cp\u003E我们先只用\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E，看看能不能编译\u003Ccode\u003Edo {...}\u003C\u002Fcode\u003E这个语法。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F do expressions stage-1语法\nlet x = 100;\nlet y = 20;\n\nlet a = do {\n    if (x &gt; 10) {\n        if (y &gt; 20) {\n            (&quot;big x, big y&quot;);\n        } else {\n            (&quot;big x, small y&quot;);\n        }\n    } else {\n        if (y &gt; 10) {\n            (&quot;small x, big y&quot;);\n        } else {\n            (&quot;small x, small y&quot;);\n        }\n    }\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003EBabel.config.js\u003C\u002Fcode\u003E配置：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Econst presets = [\n    '@babel\u002Fpreset-env'\n];\n\n\u002F\u002F const plugins = [\n    \u002F\u002F '@babel\u002Fplugin-proposal-do-expressions'\n\u002F\u002F ];\n\n\u002F\u002F module.exports = {plugins, presets};\n\nmodule.exports = {presets};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E我们会发现终端报错：\u003C\u002Fp\u003E\n\u003Cimg src=\"..\u002Fmd\u002Fknow-babel\u002Fcompole-stage-1-2.png\" width=\"100%\" \u002F\u003E\n\u003Cp\u003E大致意思是：\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E当前未启用对实验语法\u003Ccode\u003EdoExpressions\u003C\u002Fcode\u003E的支持（因为\u003Ccode\u003EdoExpressions\u003C\u002Fcode\u003E当前是\u003Ccode\u003Estage-1\u003C\u002Fcode\u003E的语法，\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E只包含必编译\u003Ccode\u003Estage-4\u003C\u002Fcode\u003E的语法插件），需要我们加入\u003Ccode\u003E@babel\u002Fplugin-proposal-do-expressions\u003C\u002Fcode\u003E插件去编译。\u003C\u002Fp\u003E\n\u003Cp\u003E那我们\u003Ccode\u003Enpm i @babel\u002Fplugin-proposal-do-expressions -D\u003C\u002Fcode\u003E，修改一下\u003Ccode\u003Ebabel.config.js\u003C\u002Fcode\u003E：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Econst presets = [\n    '@babel\u002Fpreset-env'\n];\n\nconst plugins = [\n    '@babel\u002Fplugin-proposal-do-expressions'\n];\n\nmodule.exports = {plugins, presets};\n\n\u002F\u002F module.exports = {presets};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E我们可以看到，可以正常输出编译后的文件：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E&quot;use strict&quot;;\n\nvar x = 100;\nvar y = 20;\nvar a = x &gt; 10 ? y &gt; 20 ? &quot;big x, big y&quot; : &quot;big x, small y&quot; : y &gt; 10 ? &quot;small x, big y&quot; : &quot;small x, small y&quot;;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E所以，当我们想使用小于\u003Ccode\u003Estage-4\u003C\u002Fcode\u003E阶段的语法时，我们要先找到\u003Cstrong\u003E其对应的编译插件\u003C\u002Fstrong\u003E安装，然后在\u003Ccode\u003Eplugins\u003C\u002Fcode\u003E里面配置就好了。\u003C\u002Fp\u003E\n\u003Cp\u003E参考文章：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ftc39\u002Fproposals\"\u003ETC39 proposals\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ftc39\u002Fproposal-do-expressions\"\u003Eproposal-do-expressions\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.babeljs.cn\u002Fdocs\u002Fbabel-plugin-proposal-do-expressions\"\u003E@babel\u002Fplugin-proposal-do-expressions\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3\u003E补充\u003C\u002Fh3\u003E\n\u003Cp\u003E有时我们也可能需要知道我们当前的\u003Ccode\u003Epreset\u003C\u002Fcode\u003E（预设）包含了哪些插件，那我们怎么查看当前\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E包含了哪些预设呢？\u003C\u002Fp\u003E\n\u003Cp\u003E我们可以通过查看\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E --&gt; \u003Ccode\u003Epackage.json\u003C\u002Fcode\u003E --&gt; \u003Ccode\u003Edependencies\u003C\u002Fcode\u003E里面可以找到。我目前安装的\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E版本为\u003Ccode\u003E7.20.2\u003C\u002Fcode\u003E，它包含了以下预设：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-json\"\u003E\u002F\u002F @babel\u002Fpreset-env@7.20.2预设\n&quot;dependencies&quot;: {\n    &quot;@babel\u002Fplugin-bugfix-safari-id-destructuring-collision-in-function-expression&quot;: &quot;^7.18.6&quot;,\n    &quot;@babel\u002Fplugin-bugfix-v8-spread-parameters-in-optional-chaining&quot;: &quot;^7.18.9&quot;,\n    ...,\n    &quot;@babel\u002Fplugin-transform-sticky-regex&quot;: &quot;^7.18.6&quot;,\n    &quot;@babel\u002Fplugin-transform-template-literals&quot;: &quot;^7.18.9&quot;,\n    &quot;@babel\u002Fplugin-transform-typeof-symbol&quot;: &quot;^7.18.9&quot;,\n    &quot;@babel\u002Fplugin-transform-unicode-escapes&quot;: &quot;^7.18.10&quot;,\n    &quot;@babel\u002Fplugin-transform-unicode-regex&quot;: &quot;^7.18.6&quot;,\n  },\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2\u003E\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Ch3\u003E功能\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Ccode\u003EES6+\u003C\u002Fcode\u003E除了提供很多简洁的语法（\u003Ccode\u003Elet\u003C\u002Fcode\u003E、\u003Ccode\u003Eclass\u003C\u002Fcode\u003E、\u003Ccode\u003E() =&gt; {}\u003C\u002Fcode\u003E等）外，还为我们提供了很多便捷的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E（\u003Ccode\u003EPromise\u003C\u002Fcode\u003E、\u003Ccode\u003ESymbol\u003C\u002Fcode\u003E、\u003Ccode\u003EArray.prototype.includes\u003C\u002Fcode\u003E等）。但\u003Cstrong\u003E旧版本浏览器是不支持这些\u003Ccode\u003EAPI\u003C\u002Fcode\u003E的\u003C\u002Fstrong\u003E，而\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E存放了这些\u003Ccode\u003EAPI\u003C\u002Fcode\u003E的方法与实现，所以它可以使得这些不支持的浏览器，支持这些\u003Ccode\u003EAPI\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Ch3\u003E理解\u003C\u002Fh3\u003E\n\u003Cp\u003E我们可以把所有这种存放了\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E的\u003Cstrong\u003E方法与实现的集合\u003C\u002Fstrong\u003E叫做\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E，也就是我们经常说的\u003Cstrong\u003E垫片\u003C\u002Fstrong\u003E。（如果把我们的旧版本浏览器缺失的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E当做一个个坑，\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E就是用来把这个坑填平）\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E也分很多种，像\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E是会提供旧版本浏览器缺失的\u003Cstrong\u003E所有\u003C\u002Fstrong\u003E的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E；还有一些只提供缺失\u003Ccode\u003EAPI\u003C\u002Fcode\u003E的\u003Cstrong\u003E某块\u003C\u002Fstrong\u003E，例如 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ftaylorhakes\u002Fpromise-polyfill%5B\"\u003Epromise-polyfill\u003C\u002Fa\u003E、\u003Ca href=\"https:\u002F\u002Fgithub.com\u002FGoogleChrome\u002Fproxy-polyfill\"\u003Eproxy-polyfill\u003C\u002Fa\u003E 等。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003EBabel\u003C\u002Fcode\u003E配置\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E的过程，就是实现旧版本浏览器对这些\u003Ccode\u003EAPI\u003C\u002Fcode\u003E支持的过程。\u003C\u002Fp\u003E\n\u003Ch2\u003E\u003Ccode\u003E@babel\u002Fpolyfill\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003E上面我们解释了\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E是什么，从包名\u003Ccode\u003E@babel\u002Fpolyfill\u003C\u002Fcode\u003E就知道，它就是一个\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E（其核心是依靠\u003Ccode\u003Ecore-js@2.x.x\u003C\u002Fcode\u003E实现）。虽然这个包已经被废弃了，但我们还是稍微了解一下它。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cstrong\u003E官网解释：\u003C\u002Fstrong\u003E\u003Cbr\u003E\n🚨 从Babel 7.4.0开始，这个包已经被弃用，转而直接包含\u003Ccode\u003Ecore-js\u002Fstable\u003C\u002Fcode\u003E（用于\u003Ccode\u003Epolyfill ECMAScript\u003C\u002Fcode\u003E功能）\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E使用：\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Eimport &quot;core-js\u002Fstable&quot;;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch3\u003E初识\u003C\u002Fh3\u003E\n\u003Cp\u003E我们通过这个例子 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fknow-babel-polyfill\"\u003Eknow-babel-polyfill\u003C\u002Fa\u003E，来了解一下\u003Ccode\u003E@babel\u002Fpolyfill\u003C\u002Fcode\u003E的组成。\n\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fknow-babel-polyfill\"\u003Eknow-babel-polyfill\u003C\u002Fa\u003E 什么都没安装，只安装了\u003Ccode\u003E@bable\u002Fpolyfill\u003C\u002Fcode\u003E这个依赖，我们可以很清楚看到，\u003Ccode\u003E@bable\u002Fpolyfill\u003C\u002Fcode\u003E由以下两个包组成：\u003C\u002Fp\u003E\n\u003Cimg src=\"..\u002Fmd\u002Fknow-babel\u002Fbabel-polyfill.jpeg\" width=\"100%\" \u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E（\u003Cstrong\u003E版本为\u003Ccode\u003E2\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E）\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eregenerator-runtime\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E我们来大致理解一下这两包是什么：\u003C\u002Fp\u003E\n\u003Ch4\u003E\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E\u003C\u002Fh4\u003E\n\u003Cp\u003E这个包就是我们上述\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E模块所说的，里面存放了很多\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E的方法与实现。如果要在旧浏览用到\u003Ccode\u003EPromise\u003C\u002Fcode\u003E、\u003Ccode\u003ESymbol\u003C\u002Fcode\u003E、\u003Ccode\u003EArray.prototype.includes\u003C\u002Fcode\u003E等方法时，这个包会为我们提供。它可以使那些不支持\u003Ccode\u003EAPI\u003C\u002Fcode\u003E的浏览器，支持这些\u003Ccode\u003EAPI\u003C\u002Fcode\u003E，它就是一种垫片。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cstrong\u003E特别注意\u003C\u002Fstrong\u003E：由上图可知，\u003Ccode\u003E@babel\u002Fpolyfill\u003C\u002Fcode\u003E是与\u003Ccode\u003E2\u003C\u002Fcode\u003E版本的\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E绑定的，\u003Ccode\u003E2\u003C\u002Fcode\u003E版本的\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E并不包含\u003Ccode\u003Estable\u003C\u002Fcode\u003E这个文件夹的。因此官网说的\u003Ccode\u003Eimport &quot;core-js\u002Fstable&quot;\u003C\u002Fcode\u003E，实际上是要我们安装\u003Ccode\u003Ecore-js@3.x.x\u003C\u002Fcode\u003E版本来代替\u003Ccode\u003E@babel\u002Fpolyfill\u003C\u002Fcode\u003E，因为从\u003Ccode\u003E3\u003C\u002Fcode\u003E版本开始，才有\u003Ccode\u003Estable\u003C\u002Fcode\u003E这个文件夹\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch4\u003E\u003Ccode\u003Eregenerator-runtime\u003C\u002Fcode\u003E\u003C\u002Fh4\u003E\n\u003Cp\u003E我们的源码里面使用了\u003Ccode\u003Easync function() {}\u003C\u002Fcode\u003E等异步函数，或者\u003Ccode\u003Efuction* myGenerator() {}\u003C\u002Fcode\u003E这种\u003Ccode\u003EGenerator\u003C\u002Fcode\u003E函数的话，就会需要用到这个包来编译。\u003C\u002Fp\u003E\n\u003Ch3\u003E总结\u003C\u002Fh3\u003E\n\u003Cp\u003E所以对于\u003Ccode\u003E@babel\u002Fpolyfill\u003C\u002Fcode\u003E，我们有以下总结：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E这个包由\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E（\u003Cstrong\u003E版本为\u003Ccode\u003E2.x.x\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E）与\u003Ccode\u003Eregenerator-runtime\u003C\u002Fcode\u003E两个包组成\u003C\u002Fli\u003E\n\u003Cli\u003E这个包在\u003Ccode\u003EBabel 7.4.0\u003C\u002Fcode\u003E以后就废弃了，所以在\u003Ccode\u003EBabel 7.4.0\u003C\u002Fcode\u003E以后，我们想让一些不支持\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E的旧版本浏览器支持这些\u003Ccode\u003EAPI\u003C\u002Fcode\u003E，应该直接安装\u003Ccode\u003Ecore-js@3.x.x\u003C\u002Fcode\u003E的包（\u003Cstrong\u003E不要安装\u003Ccode\u003E2.x.x\u003C\u002Fcode\u003E的版本，已经不维护了，目前最新版本为\u003Ccode\u003E3.x.x\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E；并且只有\u003Ccode\u003E3\u003C\u002Fcode\u003E的版本才有\u003Ccode\u003Estable\u003C\u002Fcode\u003E这个文件夹）\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E参考文章：\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fbabel-polyfill\"\u003E@babel\u002Fpolyfill\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch2\u003E\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Ch3\u003E概述\u003C\u002Fh3\u003E\n\u003Cp\u003E通过上面\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E、\u003Ccode\u003E@babel\u002Fpolyfill\u003C\u002Fcode\u003E两个模块，我们可以知道它是一个垫片，它会提供旧版本浏览器缺失的\u003Cstrong\u003E所有\u003C\u002Fstrong\u003E的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E，如果我们想要在旧浏览器用到\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E时，我们直接安装\u003Ccode\u003Ecore-js@3.x.x\u003C\u002Fcode\u003E这个包。\u003C\u002Fp\u003E\n\u003Cp\u003E通过 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fzloirock\u002Fcore-js#babelpolyfill\"\u003E官方的介绍\u003C\u002Fa\u003E，我们可以知道：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Eimport '@babel\u002Fpolyfill';\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E等同于\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F core-js必须是3.x.x版本，因为2.x.x版本，不包含stable文件夹\nimport &quot;core-js\u002Fstable&quot;;\nimport &quot;regenerator-runtime\u002Fruntime&quot;;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003EBabel &gt;= 7.18.0\u003C\u002Fcode\u003E等同于\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F core-js必须是3.x.x版本，因为2.x.x版本，不包含stable文件夹\n\u002F\u002F Babel &gt;= 7.18.0后 不需要再 import &quot;regenerator-runtime\u002Fruntime&quot;;\nimport &quot;core-js\u002Fstable&quot;;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3\u003E注意\u003C\u002Fh3\u003E\n\u003Cp\u003E我们针对不需要再\u003Ccode\u003Eimport &quot;regenerator-runtime\u002Fruntime&quot;\u003C\u002Fcode\u003E这块，稍微解释一下，加深一下我们对\u003Ccode\u003EBabel\u003C\u002Fcode\u003E跟官网文档的理解。\u003C\u002Fp\u003E\n\u003Cp\u003E我们看官方这段话：\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EIf you are compiling generators or async function to \u003Ccode\u003EES5\u003C\u002Fcode\u003E, and you are using a version of \u003Ccode\u003E@babel\u002Fcore\u003C\u002Fcode\u003E or \u003Ccode\u003E@babel\u002Fplugin-transform-regenerator\u003C\u002Fcode\u003E older than \u003Ccode\u003E7.18.0\u003C\u002Fcode\u003E, you must also load the \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ffacebook\u002Fregenerator\u002Ftree\u002Fmain\u002Fpackages\u002Fruntime\"\u003Eregenerator-runtime\u003C\u002Fa\u003E package\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E大家看这句话的时候可能有点疑惑，其实它的意思就是：\u003C\u002Fp\u003E\n\u003Cp\u003E如果我们要把\u003Ccode\u003Easync function() {}\u003C\u002Fcode\u003E等异步函数，或者\u003Ccode\u003Efuction* myGenerator() {}\u003C\u002Fcode\u003E这种\u003Ccode\u003EGenerator\u003C\u002Fcode\u003E函数编译成\u003Ccode\u003EES5\u003C\u002Fcode\u003E，并且\u003Ccode\u003E@babel\u002Fcore\u003C\u002Fcode\u003E或\u003Ccode\u003E@babel\u002Fplugin-transform-regenerator\u003C\u002Fcode\u003E小于\u003Ccode\u003E7.18.0\u003C\u002Fcode\u003E，我们就需要手动\u003Ccode\u003Eimport &quot;regenerator-runtime\u002Fruntime&quot;\u003C\u002Fcode\u003E这个包。\u003C\u002Fp\u003E\n\u003Cp\u003E但在\u003Ccode\u003EBabel 7.18.0\u003C\u002Fcode\u003E或者\u003Ccode\u003E@babel\u002Fplugin-transform-regenerator 7.18.0\u003C\u002Fcode\u003E及其以后的版本，\u003Ccode\u003Eregenerator-runtime\u003C\u002Fcode\u003E包里面的内容会被\u003Cstrong\u003E内联编译\u003C\u002Fstrong\u003E到我们的代码中，所以我们只用引入\u003Ccode\u003Eimport &quot;core-js\u002Fstable&quot;\u003C\u002Fcode\u003E这一个包就可以了。\u003C\u002Fp\u003E\n\u003Cp\u003E我们来用两个例子结合\u003Ccode\u003EWebpack\u003C\u002Fcode\u003E打包出来，在浏览器运行，这样更直观的理解感受一下。\u003C\u002Fp\u003E\n\u003Ch4\u003E\u003Ccode\u003EBabel &lt; 7.18.0\u003C\u002Fcode\u003E\u003C\u002Fh4\u003E\n\u003Cp\u003E我们用这个例子 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fimport-regenerator-runtime\"\u003Eimport-regenerator-runtime\u003C\u002Fa\u003E 看看在\u003Ccode\u003EBabel 7.18.0\u003C\u002Fcode\u003E之前为什么要手动引入\u003Ccode\u003Eregenerator-runtime\u003C\u002Fcode\u003E这个包。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cstrong\u003E特别说明：\u003C\u002Fstrong\u003E 我们例子安装\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的版本为\u003Ccode\u003E7.16.7\u003C\u002Fcode\u003E，\u003Ccode\u003E@babel\u002Fplugin-transform-regenerator\u003C\u002Fcode\u003E这个插件必须\u003Cstrong\u003E手动安装为小于\u003Ccode\u003E7.18.0\u003C\u002Fcode\u003E的版本\u003C\u002Fstrong\u003E（因为我们安装依赖的时候，即使指定了依赖的版本，但依赖的依赖安装时，可能会是最新的，这样可能会看不出效果。所以为什么有时我们对着官网敲\u003Ccode\u003EDemo\u003C\u002Fcode\u003E实际出来的结果不一样，因为版本没对上）。可以通过\u003Ccode\u003Epackage-lock.json\u003C\u002Fcode\u003E查看各个依赖版本\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003Eok，来看看我们的入口文件（\u003Ccode\u003Eindex.js\u003C\u002Fcode\u003E）：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F 先不引入regenerator-runtime\u002Fruntime\n\n\u002F\u002F import 'regenerator-runtime\u002Fruntime';\nconst sleep = async function() {\n    setTimeout(() =&gt; console.log('get up'), 1000);\n}\nsleep();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E接着我们打包（\u003Ccode\u003EWebpack\u003C\u002Fcode\u003E打包出来的文件在\u003Ccode\u003Edist\u002Fdist.js\u003C\u002Fcode\u003E）在浏览器运行。正常情况下，浏览器应该会过一秒后输出\u003Ccode\u003Eget up\u003C\u002Fcode\u003E。但实际情况如下，我们会发现之前网友们经常出现的一个问题——\u003Ccode\u003EregeneratorRuntime is not defined\u003C\u002Fcode\u003E：\u003C\u002Fp\u003E\n\u003Cimg src=\"..\u002Fmd\u002Fknow-babel\u002Fimport-regenerator-runtime.png\" width=\"100%\" \u002F\u003E\n\u003Cp\u003E说明缺失了\u003Ccode\u003EregeneratorRuntime\u003C\u002Fcode\u003E，我们再看看\u003Ccode\u003EBabel\u003C\u002Fcode\u003E编译后的文件（\u003Ccode\u003Ecompile.js\u003C\u002Fcode\u003E）：\u003C\u002Fp\u003E\n\u003Cimg src=\"..\u002Fmd\u002Fknow-babel\u002Fimport-regenerator-runtime-2.png\" width=\"100%\" \u002F\u003E\n\u003Cp\u003E我们发现在全局中，\u003Ccode\u003EregeneratorRuntime\u003C\u002Fcode\u003E根本没有定义，所以才报了\u003Ccode\u003EregeneratorRuntime is not defined\u003C\u002Fcode\u003E的错。\u003C\u002Fp\u003E\n\u003Cp\u003E如果我们再手动引入一下\u003Ccode\u003Eimport &quot;regenerator-runtime\u002Fruntime&quot;\u003C\u002Fcode\u003E：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Eimport 'regenerator-runtime\u002Fruntime';\n\nconst sleep = async function() {\n    setTimeout(() =&gt; console.log('get up'), 1000);\n}\nsleep();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E此时浏览器输出：\u003C\u002Fp\u003E\n\u003Cimg src=\"..\u002Fmd\u002Fknow-babel\u002Fimport-regenerator-runtime-3.png\" width=\"30%\" \u002F\u003E\n\u003Cp\u003E当我们手动引入以后，浏览器可以正常运行了。\u003C\u002Fp\u003E\n\u003Cp\u003E这说明，在\u003Ccode\u003E@babel\u002Fcore\u003C\u002Fcode\u003E或\u003Ccode\u003E@babel\u002Fplugin-transform-regenerator\u003C\u002Fcode\u003E的版本小于\u003Ccode\u003E7.18.0\u003C\u002Fcode\u003E的时候，使用了异步函数（\u003Ccode\u003Easync function() {}\u003C\u002Fcode\u003E），或者\u003Ccode\u003EGenerator\u003C\u002Fcode\u003E这种函数（\u003Ccode\u003Efuction* myGenerator() {}\u003C\u002Fcode\u003E）的话，是需要我们手动引入\u003Ccode\u003Eregenerator-runtime\u003C\u002Fcode\u003E这个包的，因为\u003Ccode\u003Eregenerator-runtime\u003C\u002Fcode\u003E\u003Cstrong\u003E这个包会为我们提供\u003Ccode\u003EregeneratorRuntime\u003C\u002Fcode\u003E这个全局对象\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n\u003Ch4\u003E\u003Ccode\u003EBabel &gt;= 7.18.0\u003C\u002Fcode\u003E\u003C\u002Fh4\u003E\n\u003Cp\u003E我们用这个例子 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fno-import-regenerator-runtime\"\u003Eno-import-regenerator-runtime\u003C\u002Fa\u003E 看看在\u003Ccode\u003EBabel 7.18.0\u003C\u002Fcode\u003E之后为什么不需要手动引入\u003Ccode\u003Eregenerator-runtime\u003C\u002Fcode\u003E这个包。（\u003Ccode\u003E@babel\u002Fcore\u003C\u002Fcode\u003E版本为\u003Ccode\u003E7.20.12\u003C\u002Fcode\u003E）\u003C\u002Fp\u003E\n\u003Cp\u003Eok，来看看我们的入口文件，这时不再手动引入\u003Ccode\u003Eregenerator-runtime\u003C\u002Fcode\u003E这个包：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Econst sleep = async function() {\n    setTimeout(() =&gt; console.log('get up'), 1000);\n}\nsleep();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E编译出包以后在浏览器运行，得到跟上述手动引入\u003Ccode\u003Eregenerator-runtime\u003C\u002Fcode\u003E这个包一模一样的效果：\u003C\u002Fp\u003E\n\u003Cimg src=\"..\u002Fmd\u002Fknow-babel\u002Fimport-regenerator-runtime-3.png\" width=\"30%\" \u002F\u003E\n\u003Cp\u003E我们再看看\u003Ccode\u003EBabel\u003C\u002Fcode\u003E编译后的文件：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp6-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F9f923b96597f4f0c948b82b5b2f01f6d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"no-import-regenerator-runtime.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E我们会发现，\u003Ccode\u003Eregenerator-runtime\u003C\u002Fcode\u003E包里的内容，会以\u003Cstrong\u003E局部变量的方式内联注入到我们的代码中\u003C\u002Fstrong\u003E，这样我们就不需要全局提供一个\u003Ccode\u003EregeneratorRuntime\u003C\u002Fcode\u003E对象了。\u003C\u002Fp\u003E\n\u003Cp\u003E所以，在\u003Ccode\u003EBabel &gt;= 7.18.0\u003C\u002Fcode\u003E以后，我们直接\u003Ccode\u003Eimport &quot;core-js\u002Fstable&quot;;\u003C\u002Fcode\u003E就好\u003C\u002Fp\u003E\n\u003Cp\u003E参考文章：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fzloirock\u002Fcore-js#babelpolyfill\"\u003Ecore-js\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fbabel-polyfill\"\u003E@babel\u002Fpolyfill\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fblog\u002F2022\u002F05\u002F19\u002F7.18.0#inline-regenerator-runtime-helper-14538httpsgithubcombabelbabelpull14538\"\u003EInline regenerator-runtime helper\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003E\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E官方解释：\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E是一个包含\u003Ccode\u003EBabel\u003C\u002Fcode\u003E模块化运行时助手的库\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E在\u003Ccode\u003EBabel\u003C\u002Fcode\u003E编译的时候，会有一些辅助函数，这些函数就是\u003Ccode\u003EES6+\u003C\u002Fcode\u003E一些语法糖的实现，我们用这个案例 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fhelper-functions\"\u003Ehelper-functions\u003C\u002Fa\u003E 看看辅助函数是什么。\u003C\u002Fp\u003E\n\u003Cp\u003E我们用\u003Ccode\u003EBabel\u003C\u002Fcode\u003E编译一下\u003Ccode\u003Eclass\u003C\u002Fcode\u003E这个语法糖：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Eclass People {\n    constructor() {\n    }\n}\nconst person  = new Person();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E编译以后：\u003C\u002Fp\u003E\n\u003Cimg src=\"..\u002Fmd\u002Fknow-babel\u002Fheplper-functions.png\" width=\"100%\" \u002F\u003E\n\u003Cp\u003E我们先看红色框，它是\u003Ccode\u003EBabel\u003C\u002Fcode\u003E编译后的代码。我们会发现，编译以后生成很多函数，并且会以内联的方式插入到我们的代码中，这些函数就是我们说的\u003Cstrong\u003E辅助函数\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E我们再看蓝色框，它是\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E的内容，它在\u003Ccode\u003Enode_modules\u002F@babel\u002Fruntime\u002Fhelpers\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E我们最后来看看白色框，会发现\u003Ccode\u003EBabel\u003C\u002Fcode\u003E编译后的辅助函数，都可以在\u003Ccode\u003E@bable\u002Fruntime\u003C\u002Fcode\u003E里面找到。\u003C\u002Fp\u003E\n\u003Cp\u003E所以\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E是\u003Cstrong\u003E存放了\u003Ccode\u003EBabel\u003C\u002Fcode\u003E辅助函数的一个集合包\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E参考文章：\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fbabel-runtime\"\u003E@babel\u002Fruntime\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch2\u003E\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E官方解释：一个插件，可以重用\u003Ccode\u003EBabel\u003C\u002Fcode\u003E注入的帮助程序代码以节省代码大小\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E通过上面\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E模块的了解，我们知道当我们使用了一些\u003Ccode\u003EES6+\u003C\u002Fcode\u003E的语法糖时，\u003Ccode\u003EBabel\u003C\u002Fcode\u003E会生成一些辅助函数来编译这些语法糖，并以\u003Cstrong\u003E内联的方式插入\u003C\u002Fstrong\u003E到代码中。\u003C\u002Fp\u003E\n\u003Cp\u003E那如果我们有10个文件都用到了语法糖，那这些辅助函数，是不是会生成10次，并内联插入10次呢？我们用这个案例 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fno-use-transform-runtime\"\u003Eno-use-transform-runtime\u003C\u002Fa\u003E 来感受一下。\u003C\u002Fp\u003E\n\u003Cp\u003E我们定义了三个文件，每个文件都用了\u003Ccode\u003Eclass\u003C\u002Fcode\u003E这个语法糖。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F babel.config.js 配置文件\nconst presets = [\n    '@babel\u002Fpreset-env'\n];\nmodule.exports = {presets};\n\n\u002F\u002F Animal.js 文件\nexport default class Animal {\n    constructor() {}\n};\n\n\u002F\u002F Country.js 文件\nexport default class Country {\n    constructor() {}\n};\n\n\u002F\u002F index.js 文件\nimport Animal from &quot;.\u002Fclass\u002FAnimal&quot;;\nimport Country from &quot;.\u002Fclass\u002FCountry&quot;;\n\nclass People {\n    constructor() {\n    }\n};\n\nconst lMC = new People();\nconst cat = new Animal();\nconst usa = new Country();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E最后打包出来文件：\u003C\u002Fp\u003E\n\u003Cimg src=\"..\u002Fmd\u002Fknow-babel\u002Fno-use-transform-runtime.png\" alt=\"big-dist-size.png\" width=\"100%\" \u002F\u003E\n\u003Cp\u003E看看红色的框框，我们会发现实现的方法都是一样的，所以在每个使用到\u003Ccode\u003Eclass\u003C\u002Fcode\u003E语法糖的文件中，辅助函数都被生成并插入了一次，这些基本重复的代码，无疑是会大大增加我们的打包体积的。目前打包出来的体积是：\u003Ccode\u003E6KB\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E为了解决上述的弊端，我们就得使用\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E插件。从\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E模块我们知道，它里面存放了\u003Ccode\u003EBabel\u003C\u002Fcode\u003E辅助函数的集合，\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E会将我们用到的辅助函数，从\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E中以\u003Ccode\u003Erequire\u003C\u002Fcode\u003E或者\u003Ccode\u003Eimport\u003C\u002Fcode\u003E的方式，引入到我们的文件中，实现复用，从而减小我们最终输出包的体积。\u003C\u002Fp\u003E\n\u003Cp\u003E所以\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E跟\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E两者通常是配合一起使用。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E备注：\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E还有一个配置功能，后续会有文章说明\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E我们用这个案例 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fuse-transform-runtime\"\u003Euse-transform-runtime\u003C\u002Fa\u003E 看看使用了\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E插件以后有什么变化。\u003C\u002Fp\u003E\n\u003Cp\u003E我们的案例代码跟上述一样，只是在\u003Ccode\u003Ebabel.config.js\u003C\u002Fcode\u003E增加了\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E配置\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F babel.config.js 配置文件\n\u002F\u002F 增加了@babel\u002Fplugin-transform-runtime 配置\nconst plugins = [\n    '@babel\u002Fplugin-transform-runtime'\n]\nconst presets = [\n    '@babel\u002Fpreset-env'\n];\nmodule.exports = {plugins, presets};\n\n\u002F\u002F Animal.js 文件\nexport default class Animal {\n    constructor() {}\n};\n\n\u002F\u002F Country.js 文件\nexport default class Country {\n    constructor() {}\n};\n\n\u002F\u002F index.js 文件\nimport Animal from &quot;.\u002Fclass\u002FAnimal&quot;;\nimport Country from &quot;.\u002Fclass\u002FCountry&quot;;\n\nclass People {\n    constructor() {\n    }\n};\n\nconst lMC = new People();\nconst cat = new Animal();\nconst usa = new Country();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E编译跟打包后的文件：\u003C\u002Fp\u003E\n\u003Cimg src=\"..\u002Fmd\u002Fknow-babel\u002Fuse-transform-runtime.png\" alt=\"big-dist-size.png\" width=\"100%\" \u002F\u003E\n\u003Cp\u003E我们会发现：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E辅助函数会以\u003Ccode\u003Erequire\u003C\u002Fcode\u003E引用的方式加到我们的代码中\u003C\u002Fli\u003E\n\u003Cli\u003E打包后，辅助函数只用了一次，而且不是插入三次，很好的实现了复用\u003C\u002Fli\u003E\n\u003Cli\u003E打包出来的体积也变成了\u003Ccode\u003E3KB\u003C\u002Fcode\u003E，很好的缩小了最后包的体积（不要小看缩小了\u003Ccode\u003E3KB\u003C\u002Fcode\u003E，只是因为我用最简单的方式写了\u003Ccode\u003EES6+\u003C\u002Fcode\u003E语法，实际中我们项目肯定没那么简单）\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E所以\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E跟\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E两者配合一起使用，一般来说是可以帮助我们大大减少打包后的体积的。\u003C\u002Fp\u003E\n\u003Ch2\u003E最后\u003C\u002Fh2\u003E\n\u003Cp\u003E如果读完这篇文章，你对\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的主要几个包已经有了更清晰的认识，那已经可以更好的深入\u003Ccode\u003EBabel\u003C\u002Fcode\u003E配置了。\u003C\u002Fp\u003E\n\u003Cp\u003E因为\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的知识体系实在太大了，所以我们应该先把\u003Ccode\u003EBabel\u003C\u002Fcode\u003E主要的几个包弄清楚，才能更好地深入配置。关于\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的配置，会后续再出文章。\u003C\u002Fp\u003E\n\u003Cp\u003E我们平常项目中\u003Ccode\u003EBabel\u003C\u002Fcode\u003E用到的包，基本就是这篇文章中讲解的几个包，这篇文章算是十分详细的介绍了这几个包了。如果大家能把这几个包弄得很清楚，\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的大部分知识也了解的差不多了。\u003C\u002Fp\u003E\n\u003Cp\u003E文章中有用到\u003Ccode\u003EWebpack\u003C\u002Fcode\u003E，如果你也想了解\u003Ccode\u003EWebpack\u003C\u002Fcode\u003E的知识，可以看看我自己用\u003Ccode\u003EWebpack5\u003C\u002Fcode\u003E搭的脚手架 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Fwebpack5-boilerplate\"\u003Ewebpack5-boilerplate\u003C\u002Fa\u003E，跟之前我写的这篇文章—— \u003Ca href=\"https:\u002F\u002Fjuejin.cn\u002Fpost\u002F7077189347941974024\"\u003Ewebpack5优化的地方及搭建的一些体会\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E如果读完这篇文章的你，觉得真的有帮助到，\u003Cstrong\u003E欢迎点赞收藏\u003C\u002Fstrong\u003E；如果有异同点，\u003Cstrong\u003E欢迎在评论区讨论\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n"}}],fetch:{},mutations:[]});