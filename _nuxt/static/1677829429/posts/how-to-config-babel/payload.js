__NUXT_JSONP__("/posts/how-to-config-babel", {data:[{posts:{attributes:{title:"Babel配置不要再“复制粘贴”了，带你自己配一个Babel",des:"告别复制粘贴，读完这篇文章，你会对Babel各配置有一个系统的理解，并且还可以自己配置一个Babel",createTime:"2023-2-8"},html:"\u003Ch1\u003E前言\u003C\u002Fh1\u003E\n\u003Ch2\u003E问题\u003C\u002Fh2\u003E\n\u003Cp\u003E我们在使用各种打包工具，需要配置\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的时候，相信大家一开始都是直接在网上\u003Cstrong\u003E复制粘贴\u003C\u002Fstrong\u003E一段配置过来，然后能跑通就万事大吉了吧？因此，我们有时会遇到打包部署后，手机运行出现白屏问题；或者是，打包后代码包过大，加载缓慢等等问题。\u003C\u002Fp\u003E\n\u003Cp\u003E其实这一切，大部分原因是因为我们对\u003Ccode\u003EBabel\u003C\u002Fcode\u003E各项配置没有一个系统的理解，所以即使从网上复制粘贴了配置，出现问题了，不知道怎么去分析出现的问题。\u003C\u002Fp\u003E\n\u003Ch2\u003E准备\u003C\u002Fh2\u003E\n\u003Cp\u003E如果你已经对\u003Ccode\u003EBabel\u003C\u002Fcode\u003E已经有一个大概的了解了，那阅读这篇文章，会让你对配置有一个更系统的了解；如果你才刚接触\u003Ccode\u003EBabel\u003C\u002Fcode\u003E，或者对\u003Ccode\u003EBabel\u003C\u002Fcode\u003E处于懵懵懂懂的状态，那我强烈建议你先阅读这篇文章——\u003Ca href=\"https:\u002F\u002Fjuejin.cn\u002Fpost\u002F7190312484492804156\"\u003E想弄懂Babel？你必须得先弄清楚这几个包\u003C\u002Fa\u003E，它主要介绍分析了一些概念跟以下几个包：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003E@babel\u002Fcore\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E@bable\u002Fcli\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E@bable\u002Fpreset-env\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E@babel\u002Fpolyfill\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E并且为我们答疑了一些看官网时的疑惑。因为在清楚了这几包后，我们学习配置这块会更容易理解一些。\u003C\u002Fp\u003E\n\u003Ch2\u003E备注\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E当前\u003Ccode\u003E@babel\u002Fcore\u003C\u002Fcode\u003E最新版本是：\u003Ccode\u003E7.20.12\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E当前\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E最新版本是：\u003Ccode\u003E7.20.2\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch1\u003E再谈\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E\u003C\u002Fh1\u003E\n\u003Cp\u003E通过上篇文章—— \u003Ca href=\"https:\u002F\u002Fjuejin.cn\u002Fpost\u002F7190312484492804156\"\u003E想弄懂Babel？你必须得先弄清楚这几个包\u003C\u002Fa\u003E我们知道：\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E是一种\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E，它提供了旧版本浏览器缺失的\u003Cstrong\u003E所有\u003C\u002Fstrong\u003E的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E的方法与实现。\u003C\u002Fp\u003E\n\u003Cp\u003E在这里，以及下文，我们把通过引入\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E的\u003Cstrong\u003E某个模块\u003C\u002Fstrong\u003E，来实现旧版本浏览器不支持的\u003Cstrong\u003E某个\u003C\u002Fstrong\u003E\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E的过程，叫做垫平。\u003C\u002Fp\u003E\n\u003Cp\u003E我们看看\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E这个包里面的主要一些模块：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fc2ec2dac2a8048378ec646d10d1e4063~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_5.png\"\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Ees\u003C\u002Fcode\u003E：里面只包含有稳定的\u003Ccode\u003EES\u003C\u002Fcode\u003E功能。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eproposals\u003C\u002Fcode\u003E：里面包含所有\u003Ccode\u003Estage\u003C\u002Fcode\u003E阶段的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Estable\u003C\u002Fcode\u003E：它里面包含了，只有稳定的\u003Ccode\u003EES\u003C\u002Fcode\u003E功能跟网络标准\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E所以，我们可以这么使用：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E当我们只需要垫平\u003Cstrong\u003E某个\u003C\u002Fstrong\u003E稳定的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，我们可以用\u003Ccode\u003Ees\u003C\u002Fcode\u003E这个文件夹里的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E来垫平 （\u003Ccode\u003Eimport X from 'es\u002Fxx'\u003C\u002Fcode\u003E）\u003C\u002Fli\u003E\n\u003Cli\u003E当我们需要用到\u003Cstrong\u003E提案阶段\u003C\u002Fstrong\u003E的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E时，我就用\u003Ccode\u003Eproposals\u003C\u002Fcode\u003E这个文件夹里的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E来垫平（\u003Ccode\u003Eimport X from 'proposals\u002Fxx'\u003C\u002Fcode\u003E）\u003C\u002Fli\u003E\n\u003Cli\u003E当我们想垫平\u003Cstrong\u003E所有稳定版本\u003C\u002Fstrong\u003E的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，可以导入用\u003Ccode\u003Estable\u003C\u002Fcode\u003E文件夹（\u003Ccode\u003Eimport 'core-js\u002Fstable'\u003C\u002Fcode\u003E）\u003C\u002Fli\u003E\n\u003Cli\u003E当我们想垫平\u003Cstrong\u003E所有\u003C\u002Fstrong\u003E的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E（包括提案阶段），可以直接\u003Ccode\u003Eimport 'core-js'\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E以上是我个人的使用习惯，因人而异，具体的介绍可以看看参考文章。\u003C\u002Fp\u003E\n\u003Cp\u003E参考文章：\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fzloirock\u002Fcore-js#commonjs-api\"\u003Ecore-js\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch1\u003E再谈\u003Ccode\u003E@bable\u002Fpreset-env\u003C\u002Fcode\u003E\u003C\u002Fh1\u003E\n\u003Cp\u003E通过上篇文章—— \u003Ca href=\"https:\u002F\u002Fjuejin.cn\u002Fpost\u002F7190312484492804156\"\u003E想弄懂Babel？你必须得先弄清楚这几个包\u003C\u002Fa\u003E，我们知道：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003EBabel\u003C\u002Fcode\u003E大体由两个功能组成：\n\u003Col\u003E\n\u003Cli\u003E编译\u003Ccode\u003EES6+\u003C\u002Fcode\u003E最新语法（\u003Ccode\u003Elet\u003C\u002Fcode\u003E、\u003Ccode\u003Eclass\u003C\u002Fcode\u003E、\u003Ccode\u003E() =&gt; {}\u003C\u002Fcode\u003E等）\u003C\u002Fli\u003E\n\u003Cli\u003E实现旧版本浏览器不支持的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E（\u003Ccode\u003EPromise\u003C\u002Fcode\u003E、\u003Ccode\u003ESymbol\u003C\u002Fcode\u003E、\u003Ccode\u003EArray.prototype.includes\u003C\u002Fcode\u003E等）\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E有以下两个功能：\n\u003Col\u003E\n\u003Cli\u003E它\u003Cstrong\u003E只编译\u003Ccode\u003EES6+\u003C\u002Fcode\u003E语法\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E它并不提供\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E，但是可以通过\u003Cstrong\u003E配置\u003C\u002Fstrong\u003E我们代码运行的\u003Cstrong\u003E目标环境\u003C\u002Fstrong\u003E，从而控制\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E的导入跟语法编译，使\u003Ccode\u003EES6+\u003C\u002Fcode\u003E的新特性可以在我们想要的\u003Cstrong\u003E目标环境\u003C\u002Fstrong\u003E中顺利运行\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E也有以下两个功能：\n\u003Col\u003E\n\u003Cli\u003E\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E跟\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E两者配合，可以减少打包体积\u003C\u002Fli\u003E\n\u003Cli\u003E也有一个配置功能，用来处理\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E如何垫平\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E如果我们想要在旧浏览器用到\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E时，我们应该安装\u003Ccode\u003E3\u003C\u002Fcode\u003E版本的\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E（或者后续更高版本的）；\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E那我们可以很清楚的知道：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E实现\u003Ccode\u003EBabel\u003C\u002Fcode\u003E第一个功能：我们用\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E就可以了\u003C\u002Fli\u003E\n\u003Cli\u003E实现\u003Ccode\u003EBabel\u003C\u002Fcode\u003E第二个功能：我们就需要用\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E这个包来提供\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E，并与\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E或者\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E的配置功能相互配合使用\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E我们先来看看\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E的配置项有哪些：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F babel.config.js\nconst presets = [\n    [\n        '@babel\u002Fpreset-env',\n        {\n            modules,\n            targets,\n            corejs,\n            useBuiltIns,\n            \n            spec,\n            loose,\n            debug,\n            bugfixes,\n            include,\n            exclude,\n            forceAllTransforms,\n            configPath,\n            ignoreBrowserslistConfig,\n            browserslistEnv,\n            shippedProposals\n        }\n    ]\n];\nmodule.exports = {presets};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E我们可以看到配置项还是蛮多的（有一些配置项，后期可能会废弃），但是，其实我们平时项目中主要用到前四个配置，所以在这里我们重点来看看前四个配置（能不学的尽量不学，太累了）。\u003C\u002Fp\u003E\n\u003Cp\u003E参考文章：\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fbabel-preset-env\"\u003E@babel\u002Fpreset-env\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch2\u003E\u003Ccode\u003Emodules\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E功能：启用\u003Ccode\u003EES\u003C\u002Fcode\u003E模块语法向另一种模块类型的转换\u003C\u002Fli\u003E\n\u003Cli\u003E默认值：\u003Ccode\u003Eauto\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E可取的值：\u003Ccode\u003E&quot;amd&quot; | &quot;umd&quot; | &quot;systemjs&quot; | &quot;commonjs&quot; | &quot;cjs&quot; | &quot;auto&quot; | false\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E当我们设置成\u003Ccode\u003Efalse\u003C\u002Fcode\u003E的时候，\u003Ccode\u003EBabel\u003C\u002Fcode\u003E编译产生的一些辅助函数的引入方式会变成\u003Ccode\u003EES6\u003C\u002Fcode\u003E的模式引入（\u003Ccode\u003Eimport A from 'B'\u003C\u002Fcode\u003E）。\u003C\u002Fp\u003E\n\u003Cp\u003E我们把 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fuse-transform-runtime\"\u003Euse-transform-runtime\u003C\u002Fa\u003E 这个案例\u003Ccode\u003EBabel\u003C\u002Fcode\u003E配置改成以下配置，感受一下\u003Ccode\u003Emodules\u003C\u002Fcode\u003E这个配置的功能。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F babel.config.js\n\nconst plugins = [\n    '@babel\u002Fplugin-transform-runtime'\n]\n\nconst presets = [\n    [\n        '@babel\u002Fpreset-env',\n        {\n            modules: false\n        }\n    ]\n];\n\nmodule.exports = {plugins, presets};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在\u003Cstrong\u003E没设置\u003Ccode\u003Emodules\u003C\u002Fcode\u003E配置项\u003C\u002Fstrong\u003E时，编译后的文件是：\n\u003Cimg src=\"https:\u002F\u002Fp1-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F18b572077d4544cd8665e685b5ac4c96~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_1.png\" width=\"100%\" \u002F\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E我们会发现辅助函数都是以\u003Ccode\u003Erequire\u003C\u002Fcode\u003E的方式引入的；\u003C\u002Fp\u003E\n\u003Cp\u003E在\u003Cstrong\u003E设置了\u003Ccode\u003Emodules\u003C\u002Fcode\u003E配置项\u003C\u002Fstrong\u003E后，编译后的文件是：\n\u003Cimg src=\"https:\u002F\u002Fp1-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fe7d5f9f36a4c4402b2e6c67d075c4495~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_2.png\" width=\"100%\" \u002F\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E我们会发现辅助函数变成了我们熟悉的\u003Ccode\u003EES6\u003C\u002Fcode\u003E模块方式\u003Ccode\u003Eimport\u003C\u002Fcode\u003E引入。\u003C\u002Fp\u003E\n\u003Cp\u003E这样有一个好处，就是我们用一些像\u003Ccode\u003EWebpack\u003C\u002Fcode\u003E打包工具时，可以对代码静态分析，很好地\u003Ccode\u003Etree shaking\u003C\u002Fcode\u003E减少代码体积，所以我们配置\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的时候建议设置\u003Ccode\u003Emodules: false\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E参考文章：\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fbabel-preset-env#modules\"\u003Emodules\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch2\u003E\u003Ccode\u003Etargets\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Ch3\u003E作用\u003C\u002Fh3\u003E\n\u003Cp\u003E它的用法与 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbrowserslist\u002Fbrowserslist\"\u003Ebrowserslist\u003C\u002Fa\u003E 一致。它可以用来设置我们的代码需要兼容的\u003Cstrong\u003E目标环境\u003C\u002Fstrong\u003E，因此它：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E可以有效地减少\u003Ccode\u003EES6+\u003C\u002Fcode\u003E的语法编译\u003C\u002Fli\u003E\n\u003Cli\u003E可以有效控制\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E导入多少\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3\u003E注意\u003C\u002Fh3\u003E\n\u003Ch4\u003E第一点\u003C\u002Fh4\u003E\n\u003Cp\u003E如果我们没有设置这个配置项时，它会去我们的\u003Ccode\u003EBabel\u003C\u002Fcode\u003E配置文件找\u003Cstrong\u003E顶层的\u003C\u002Fstrong\u003E\u003Ccode\u003Etargets\u003C\u002Fcode\u003E；如果顶层没有设置\u003Ccode\u003Etargets\u003C\u002Fcode\u003E，则会去我们的\u003Ccode\u003Epackage.json\u003C\u002Fcode\u003E里的\u003Ccode\u003Ebrowserslist\u003C\u002Fcode\u003E或者根目录找\u003Ccode\u003E.browserslistrc\u003C\u002Fcode\u003E；如果还没有则默认值为\u003Ccode\u003E{}\u003C\u002Fcode\u003E。查找过程大致如下，序号代表查找顺序：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F Babel配置文件\n{\n    targets: 'ie 10', \u002F\u002F 2. 如果presets里面没有设置targets，会来这里查找\n    presets: [\n        [\n            '@babel\u002Fpreset-env',\n            {\n                targets: 'ie 9' \u002F\u002F 1. 先在这里查找，没的话去顶层targets查找\n            }\n        ]\n    ]\n}\n\n\u002F\u002F package.json\n{\n    ...,\n    browserslist: [\n        'ie 11' \u002F\u002F 3. 如果顶层targest里面没有设置，会来这里查找；如果这里也没设置，则为默认值{}\n    ]\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch4\u003E第二点\u003C\u002Fh4\u003E\n\u003Cp\u003E如果我们没有设置这个配置项时，\u003Ccode\u003EBabel\u003C\u002Fcode\u003E会假设我们要兼容的目标环境是最旧的浏览器，所以会将所有的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E语法代码转化为\u003Ccode\u003EES5\u003C\u002Fcode\u003E。\u003Cstrong\u003E所以我们配置\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的时候，要设置\u003Ccode\u003Etargets\u003C\u002Fcode\u003E以减少输出代码大小。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E针对这点，我们用这个案例 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fpreset-env-targets-config\"\u003Epreset-env-targets-config\u003C\u002Fa\u003E 来感受一下：\n\u003Cimg src=\"https:\u002F\u002Fp1-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fb7d9baa51e264f28abf29f1a52318182~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_3.png\" width=\"100%\" \u002F\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E我们会发现\u003Ccode\u003EES6+\u003C\u002Fcode\u003E的写法全部被转成了\u003Ccode\u003EES5\u003C\u002Fcode\u003E，还加入了一些辅助函数（白色框）。\u003C\u002Fp\u003E\n\u003Cp\u003Eok，我们设置\u003Ccode\u003Etargets: 'chrome 80'\u003C\u002Fcode\u003E。这表示，我们的代码是要在\u003Ccode\u003Echrome 80\u003C\u002Fcode\u003E上运行的，再看看打包后的结果：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp1-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fd99598f6781e42ffaef077d98ed1bd25~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_4.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E我们会发现编译出来的代码，跟我们入口文件写的代码基本没差。因为\u003Ccode\u003Echrome 80\u003C\u002Fcode\u003E已经实现了入口文件代码的写法了。所以，\u003Cstrong\u003E如果我们的代码不需要在一些比较低端的浏览器跑的话，设置\u003Ccode\u003Etargets\u003C\u002Fcode\u003E就十分有必要。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E参考文章：\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Foptions#targets\"\u003Etargets\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch2\u003E\u003Ccode\u003Ecorejs\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003E当\u003Ccode\u003EuseBuiltIns\u003C\u002Fcode\u003E不为\u003Ccode\u003Efalse\u003C\u002Fcode\u003E的时候，需要设置这个配置项\u003C\u002Fp\u003E\n\u003Ch3\u003E配置\u003C\u002Fh3\u003E\n\u003Cp\u003E它有两种配置方式：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\n\u003Cp\u003E直接设置\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E版本号\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E...\n{\n    useBuiltIns: 'usage',\n    corejs: '3.27.2'\n}\n...\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E配置\u003Ccode\u003Ecorejs\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E...\n{\n    useBuiltIns: 'usage',\n    corejs: {\n        version: '3.27.2',\n        \u002F\u002F 是否编译提案阶段ES6+ API\n        proposals: false\n    },\n}\n...\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3\u003E注意\u003C\u002Fh3\u003E\n\u003Col\u003E\n\u003Cli\u003E当我们的\u003Ccode\u003EuseBuiltIns\u003C\u002Fcode\u003E不为\u003Ccode\u003Efalse\u003C\u002Fcode\u003E的时候，需要设置\u003Ccode\u003Ecorejs\u003C\u002Fcode\u003E这个配置项\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E2\u003C\u002Fcode\u003E版本的\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E已经不建议使用了；我们用当然要用最新的，目前最新的版本是\u003Ccode\u003Ecore-js@3.27.2\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E我们安装的\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E要尽量保持最新，因为越新的包，包含的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E才会越多\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E我们设置\u003Ccode\u003Ecorejs\u003C\u002Fcode\u003E的版本号时，不要直接指定\u003Ccode\u003E2\u003C\u002Fcode\u003E或者\u003Ccode\u003E3\u003C\u002Fcode\u003E，它会被解析为\u003Ccode\u003E2.0\u003C\u002Fcode\u003E或者\u003Ccode\u003E3.0\u003C\u002Fcode\u003E。所以，我们应该带上\u003Cstrong\u003E子版本号\u003C\u002Fstrong\u003E（\u003Ccode\u003E3.27.2\u003C\u002Fcode\u003E），这样才会有最新的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E默认用\u003Cstrong\u003E稳定版\u003C\u002Fstrong\u003E的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E来垫平，但如果有时我们想用还处在提案阶段的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E怎么办？\n\u003Cul\u003E\n\u003Cli\u003E如果我们配置的是\u003Ccode\u003EuseBuiltIns: entry\u003C\u002Fcode\u003E，我们得手动引入\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E提案的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E来垫平。\u003Cstrong\u003E提案的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E放在\u003Ccode\u003Ecore-js\u002Fproposals\u003C\u002Fcode\u003E文件夹中\u003C\u002Fstrong\u003E（\u003Ccode\u003Eimport 'core-js\u002Fproposals\u002Farray-last'\u003C\u002Fcode\u003E）\u003C\u002Fli\u003E\n\u003Cli\u003E如果我们配置的是\u003Ccode\u003EuseBuiltIns: 'usage'\u003C\u002Fcode\u003E，则我们用上面说的\u003Ccode\u003Ecorejs\u003C\u002Fcode\u003E模块里面提到的第二种配置方式，把\u003Ccode\u003Eproposals\u003C\u002Fcode\u003E设为\u003Ccode\u003Etrue\u003C\u002Fcode\u003E就可以了\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E它的作用会结合下面的\u003Ccode\u003EuseBuiltIns\u003C\u002Fcode\u003E一起讲。\u003C\u002Fp\u003E\n\u003Cp\u003E参考文章：\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fbabel-preset-env#targets\"\u003Etargets\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch2\u003E\u003Ccode\u003EuseBuiltIns\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003E上面我们提到了，我们把通过引入\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E的\u003Cstrong\u003E某个模块\u003C\u002Fstrong\u003E，来实现旧版本浏览器不支持的\u003Cstrong\u003E某个\u003C\u002Fstrong\u003E\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E的过程，叫做垫平。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E这个配置就是用来设置我们\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E的垫平方式的\u003C\u002Fstrong\u003E。它有下面三个值：\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E为了更好的理解，我们用\u003Ccode\u003EPromise\u003C\u002Fcode\u003E这个\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E作为下面的例子。我们都知道：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003EIE 11\u003C\u002Fcode\u003E并不支持\u003Ccode\u003EPromise\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EPromise\u003C\u002Fcode\u003E这个对象其实还有很多方法，例如\u003Ccode\u003EPromise.any\u003C\u002Fcode\u003E、\u003Ccode\u003EPromise.all\u003C\u002Fcode\u003E、\u003Ccode\u003EPromise.finally\u003C\u002Fcode\u003E等。\u003C\u002Fli\u003E\n\u003Cli\u003E我们用这个案例 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fpreset-env-useBuiltIns-config\"\u003Epreset-env-useBuiltIns-config\u003C\u002Fa\u003E 来讲解\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch3\u003E\u003Ccode\u003Eentry\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003E我们可以这么理解，\u003Ccode\u003Eentry\u003C\u002Fcode\u003E中文是“进入”的意思，这个值说明我们的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E应该是需要从某个\u003Cstrong\u003E入口\u003C\u002Fstrong\u003E引入来垫平。\u003C\u002Fp\u003E\n\u003Ch4\u003E表现\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Cstrong\u003E我们把配置设置为：\u003Ccode\u003EuseBuiltIns: 'entry'\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E我们先来看看这个配置在\u003Ccode\u003EIE 11\u003C\u002Fcode\u003E的表现形式，我们设置\u003Ccode\u003Etargets: 'ie 11'\u003C\u002Fcode\u003E：\n\u003Cimg src=\"https:\u002F\u002Fp1-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F21e469e9c3a047348d727a48f5b3a6fd~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_6.png\" width=\"80%\" \u002F\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E我们再把\u003Ccode\u003Etargets\u003C\u002Fcode\u003E设置成\u003Ccode\u003Echrome: 80\u003C\u002Fcode\u003E看看表现：\n\u003Cimg src=\"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F76f58521eb6f415c891554e41d557715~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_9.png\" width=\"80%\" \u002F\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4\u003E分析\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E在\u003Ccode\u003EIE 11\u003C\u002Fcode\u003E的表现\u003C\u002Fp\u003E\n\u003Cp\u003E我们\u003Ccode\u003Eimport 'core-js\u002Fes\u002Fpromise'\u003C\u002Fcode\u003E（相当于\u003Ccode\u003Eimport\u003C\u002Fcode\u003E某块\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E来垫平），由于我们的\u003Ccode\u003EIE 11\u003C\u002Fcode\u003E不支持\u003Ccode\u003EPromise\u003C\u002Fcode\u003E，所以\u003Ccode\u003EuseBuiltIns: 'entry'\u003C\u002Fcode\u003E配置把我们\u003Cstrong\u003E所有\u003C\u002Fstrong\u003E不支持的\u003Ccode\u003EPromise\u003C\u002Fcode\u003E方法都垫平了（打印的\u003Ccode\u003Ewindow.Promise.any\u003C\u002Fcode\u003E有值）。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E在\u003Ccode\u003Echrome 80\u003C\u002Fcode\u003E表现\u003C\u002Fp\u003E\n\u003Cp\u003E我们\u003Ccode\u003Eimport 'core-js\u002Fes\u002Fpromise'\u003C\u002Fcode\u003E（相当于\u003Ccode\u003Eimport\u003C\u002Fcode\u003E某块\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E来垫平）， 因为在\u003Ccode\u003Echrome 80\u003C\u002Fcode\u003E中，\u003Ccode\u003EPromise\u003C\u002Fcode\u003E大部分方法已经实现，只有\u003Ccode\u003EPromise.any\u003C\u002Fcode\u003E没有实现，所以此时只垫平了\u003Ccode\u003Epromise.any\u003C\u002Fcode\u003E方法。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4\u003E总结\u003C\u002Fh4\u003E\n\u003Cp\u003E所以我们可以总结出，它的执行原理大致是这样的：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E我们需要\u003Cstrong\u003E手动\u003C\u002Fstrong\u003E\u003Ccode\u003Eimport\u003C\u002Fcode\u003E\u003Cstrong\u003E所有\u003C\u002Fstrong\u003E或者\u003Cstrong\u003E某块\u003C\u002Fstrong\u003E\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EBabel\u003C\u002Fcode\u003E会根据我们设置的\u003Ccode\u003Etargets\u003C\u002Fcode\u003E（目标环境），来判断我们手动\u003Ccode\u003Eimport\u003C\u002Fcode\u003E的\u003Cstrong\u003E所有\u003C\u002Fstrong\u003E或者\u003Cstrong\u003E某块\u003C\u002Fstrong\u003E\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E是不是当前缺失的\u003C\u002Fli\u003E\n\u003Cli\u003E如果是的话，就会把我们手动\u003Ccode\u003Eimport\u003C\u002Fcode\u003E\u003Cstrong\u003E所有\u003C\u002Fstrong\u003E或者\u003Cstrong\u003E某块\u003C\u002Fstrong\u003E\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E，拆分成很多小模块，\u003Cstrong\u003E引入我们目标环境不支持的模块\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch4\u003E注意\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E为了避免一些奇奇怪怪的问题，我们手动\u003Ccode\u003Eimport\u003C\u002Fcode\u003E的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E应该\u003Cstrong\u003E统一在入口文件\u003C\u002Fstrong\u003E（我们现在的工程项目一般都会有一个入口文件）\u003C\u002Fli\u003E\n\u003Cli\u003E如果我们想一劳永逸，直接把当前环境\u003Cstrong\u003E所有\u003C\u002Fstrong\u003E不支持的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E垫平，那我们就\u003Ccode\u003Eimport 'core-js\u002Fstable'\u003C\u002Fcode\u003E（这会垫平当前\u003Ccode\u003Etargets\u003C\u002Fcode\u003E\u003Cstrong\u003E不支持的所有稳定版本的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E，所以也会导致包变大）\u003C\u002Fli\u003E\n\u003Cli\u003E如果我们只想单纯垫平\u003Cstrong\u003E某个\u003C\u002Fstrong\u003E\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E（前提是\u003Ccode\u003Etargets\u003C\u002Fcode\u003E不支持这个\u003Ccode\u003EAPI\u003C\u002Fcode\u003E，否则手动\u003Ccode\u003Eimport\u003C\u002Fcode\u003E了也没用；例如只想垫平\u003Ccode\u003EPromise\u003C\u002Fcode\u003E），那我们\u003Ccode\u003Eimport 'core-js\u002Fes\u002Fpromise\u003C\u002Fcode\u003E就可以了\u003C\u002Fli\u003E\n\u003Cli\u003E如果想垫平提案阶段的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E，则也需要手动\u003Ccode\u003Eimport\u003C\u002Fcode\u003E对应提案的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E（\u003Ccode\u003Eimport &quot;core-js\u002Fproposals\u002Fstring-replace-all\u003C\u002Fcode\u003E）\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E参考文章：\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fbabel-preset-env#usebuiltins\"\u003Eusebuiltins\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch3\u003E\u003Ccode\u003Eusage\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003E这个值的作用，就是我们不需要手动\u003Ccode\u003Eimport\u003C\u002Fcode\u003E，它会自动帮我们\u003Ccode\u003Eimport\u003C\u002Fcode\u003E当前\u003Ccode\u003Etargets\u003C\u002Fcode\u003E缺失的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Ch4\u003E表现\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Cstrong\u003E我们把配置设置为：\u003Ccode\u003EuseBuiltIns: 'usage'\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E我们先来看看这个配置在\u003Ccode\u003EIE 11\u003C\u002Fcode\u003E的表现形式，我们设置\u003Ccode\u003Etargets: 'ie 11'\u003C\u002Fcode\u003E：\n\u003Cimg src=\"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F2382dcfb58994b8dbee0ca9f1b392ee8~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_7.png\" width=\"80%\" \u002F\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E我们再把\u003Ccode\u003Etargets\u003C\u002Fcode\u003E设置成\u003Ccode\u003Echrome: 80\u003C\u002Fcode\u003E看看表现：\n\u003Cimg src=\"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F1380f0b5bd8f48a4b2ae993f0b326c54~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_10.png\" width=\"80%\" \u002F\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4\u003E分析\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E在\u003Ccode\u003EIE 11\u003C\u002Fcode\u003E的表现\u003C\u002Fp\u003E\n\u003Cp\u003E我们不用自己手动\u003Ccode\u003Eimport\u003C\u002Fcode\u003E相关\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E，我们的代码中只用到了单一的\u003Ccode\u003EPromise\u003C\u002Fcode\u003E对象，所以\u003Cstrong\u003E只垫平\u003C\u002Fstrong\u003E了\u003Ccode\u003EPromise\u003C\u002Fcode\u003E这个对象，不会垫平它其他相关的方法（打印的\u003Ccode\u003Ewindow.Promise.any\u003C\u002Fcode\u003E无值）。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E在\u003Ccode\u003Echrome 80\u003C\u002Fcode\u003E的表现\u003C\u002Fp\u003E\n\u003Cp\u003E我们不用自己手动\u003Ccode\u003Eimport\u003C\u002Fcode\u003E相关\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E，此时没有任何关于\u003Ccode\u003EPromise\u003C\u002Fcode\u003E的垫平，因为单一的\u003Ccode\u003EPromise\u003C\u002Fcode\u003E对象在\u003Ccode\u003Echrome 80\u003C\u002Fcode\u003E已经实现，且我们代码中没有用\u003Ccode\u003EPromise.any\u003C\u002Fcode\u003E方法，自然也就不会垫平\u003Ccode\u003EPromise.any\u003C\u002Fcode\u003E。此时代码只垫平了提案阶段的\u003Ccode\u003Earray.lastItem\u003C\u002Fcode\u003E方法，\u003Cstrong\u003E因为\u003Ccode\u003Echrome 80\u003C\u002Fcode\u003E不支持它，并且我们代码中用到了它\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4\u003E总结\u003C\u002Fh4\u003E\n\u003Cp\u003E所以我们可以总结出，它的执行原理大致是这样的：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E我们\u003Cstrong\u003E不需要手动\u003C\u002Fstrong\u003E\u003Ccode\u003Eimport\u003C\u002Fcode\u003E\u003Cstrong\u003E所有\u003C\u002Fstrong\u003E或者\u003Cstrong\u003E某块\u003C\u002Fstrong\u003E\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EBabel\u003C\u002Fcode\u003E会根据我们当前代码中用到的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，并判断当前的\u003Ccode\u003Etargets\u003C\u002Fcode\u003E支不支持我们用到的这个\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E如果不支持的话，则\u003Cstrong\u003E自动导入这个\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E对应的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E因为它会自动导入，所以我们专注写我们的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E就好了。\u003C\u002Fp\u003E\n\u003Cp\u003E参考文章：\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fbabel-preset-env#usebuiltins\"\u003Eusebuiltins\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch3\u003E\u003Ccode\u003Efalse\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003E它是默认值。它表示不要在每个文件中自动添加\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E，也\u003Cstrong\u003E不会根据\u003Ccode\u003Etargets\u003C\u002Fcode\u003E判断\u003C\u002Fstrong\u003E缺不缺失，也不会将我们手动\u003Ccode\u003Eimport\u003C\u002Fcode\u003E\u003Cstrong\u003E所有\u003C\u002Fstrong\u003E或者\u003Cstrong\u003E某块\u003C\u002Fstrong\u003E\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E拆分为单个\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E引入。\u003C\u002Fp\u003E\n\u003Ch4\u003E表现\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Cstrong\u003E我们把配置设置为：\u003Ccode\u003EuseBuiltIns: false\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E我们先来看看这个配置在\u003Ccode\u003EIE 11\u003C\u002Fcode\u003E的表现形式，我们设置\u003Ccode\u003Etargets: 'ie 11'\u003C\u002Fcode\u003E：\n\u003Cimg src=\"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F7c4213601f9b4ad8ac64e7c90a275f95~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_8.png\" width=\"80%\" \u002F\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E我们再把\u003Ccode\u003Etargets\u003C\u002Fcode\u003E设置成\u003Ccode\u003Echrome: 80\u003C\u002Fcode\u003E看看表现：\n\u003Cimg src=\"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F02c4378fcbbe4cb3a3151495e6db4946~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_11.png\" width=\"80%\" \u002F\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4\u003E总结\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Ccode\u003EuseBuiltIns\u003C\u002Fcode\u003E设置为\u003Ccode\u003Efalse\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E对我们的垫平方式没作用，源码是什么样，输出就是什么样\u003C\u002Fli\u003E\n\u003Cli\u003E设置\u003Ccode\u003Etargets\u003C\u002Fcode\u003E无效\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E参考文章：\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fbabel-preset-env#usebuiltins\"\u003Eusebuiltins\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch2\u003E使用\u003C\u002Fh2\u003E\n\u003Ch3\u003E适配 \u003Ccode\u003EIE 11\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003E相信通过上面的讲解，我们对各个配置项有个大概的了解了，那我们再更深入体验一下。\u003C\u002Fp\u003E\n\u003Cp\u003E我们都知道\u003Ccode\u003EIE 11\u003C\u002Fcode\u003E基本是不支持\u003Ccode\u003EES6+\u003C\u002Fcode\u003E的，我们抽几个常用的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E看看：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F2c1e3a9a90294006adff790641b23e8a~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_12.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E那我们就用\u003Ccode\u003EIE 11\u003C\u002Fcode\u003E作为我们的\u003Ccode\u003Etargets\u003C\u002Fcode\u003E（目标环境），研究一下如何配置\u003Ccode\u003EBabel\u003C\u002Fcode\u003E，使我们写的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E代码能在\u003Ccode\u003EIE 11\u003C\u002Fcode\u003E中跑起来。我们用这个案例 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fpreset-env-template-config\"\u003Epreset-env-template-config\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E注意：\n为了避免\u003Ccode\u003EWebpack\u003C\u002Fcode\u003E打包错误，我们把\u003Ccode\u003Etargets\u003C\u002Fcode\u003E写在\u003Ccode\u003Epackage.json\u003C\u002Fcode\u003E中，这样\u003Ccode\u003EWebpack\u003C\u002Fcode\u003E才能识别环境打包\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-json\"\u003E...\n&quot;browserslist&quot;: [\n   &quot;ie 11&quot;\n ]\n ...\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E我们用一下这段代码作为我们的入口文件：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F 如果用`usage`方式，则注释掉这段代码\nimport 'core-js\u002Fstable';\n\nconst lMC = {\n    name: 'limingcan',\n    like: ['eat', 'drink', 'play', 'fun'],\n    breath() {\n        return new Promise(resolve =&gt; {\n            setTimeout(() =&gt; resolve(), 1000)\n        })\n    }\n};\n\nlMC.breath().then(() =&gt; console.log('breath'));\nconsole.log(lMC.like.includes('play'));\nconsole.log(Array.of(1, 2, 3));\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E根据我们上面几个配置项的讲解，如果我们想：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E一劳永逸的直接垫平\u003Ccode\u003Etargets\u003C\u002Fcode\u003E所有不支持的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，那我们的配置应该是：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Econst presets = [\n    [\n        '@babel\u002Fpreset-env',\n        {\n            modules: false,\n            useBuiltIns: 'entry',\n            corejs: {\n                version: '3.27.2',\n                proposals: true\n            }\n        }\n    ]\n];\nmodule.exports = { presets};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E此时\u003Ccode\u003EIE 11\u003C\u002Fcode\u003E正常输出：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fe048d0dd3ed840b29ab32bf99466aaa7~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_13.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E红色框是我们源码中\u003Cstrong\u003E没用到的\u003C\u002Fstrong\u003E\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，也都被垫平了；此时包的大小有\u003Ccode\u003E115K\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E如果我们想减少包的体积，只垫平我们用到的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，那我们的配置应该是：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Econst presets = [\n    [\n        '@babel\u002Fpreset-env',\n        {\n            modules: false,\n            useBuiltIns: 'usage',\n            corejs: {\n                version: '3.27.2',\n                proposals: true\n            }\n        }\n    ]\n];\nmodule.exports = { presets};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E此时\u003Ccode\u003EIE 11\u003C\u002Fcode\u003E正常输出：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fe3d9c1537f354d6ea66f711f560eb9d3~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_14.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E但是我们会发现，红色框是我们源码中没用到的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，它并没有被垫平的，它只会垫平我们代码中用到的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E；此时包的大小只有\u003Ccode\u003E29K\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3\u003E常见问题\u003C\u002Fh3\u003E\n\u003Cp\u003E通过上面的例子，我们会发现：\u003C\u002Fp\u003E\n\u003Cp\u003E如果配置是\u003Ccode\u003EuseBuiltIns: 'entry'\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E我们垫平的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E，都是注入到\u003Ccode\u003Ewindow\u003C\u002Fcode\u003E全局的，或者是某个内置对象的原型（\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E）上，这\u003Cstrong\u003E影响到了全局\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E一劳永逸的方式会垫平当前\u003Ccode\u003Etargets\u003C\u002Fcode\u003E\u003Cstrong\u003E所有不支持的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E，这虽然方便，但这会导致\u003Cstrong\u003E包变得很大\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E如果配置是\u003Ccode\u003EuseBuiltIns: 'usage'\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E它也会将垫平的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E注入到全局。\u003C\u002Fli\u003E\n\u003Cli\u003E由于\u003Ccode\u003EuseBuiltIns: 'usage'\u003C\u002Fcode\u003E是判断当前\u003Ccode\u003Etargets\u003C\u002Fcode\u003E支不支持我们代码中用到的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，如果不支持会自己\u003Ccode\u003Eimport\u003C\u002Fcode\u003E。\u003Cbr\u003E\n那有这样一种情况，如果第三方库用到了我们当前\u003Ccode\u003Etargets\u003C\u002Fcode\u003E不支持的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，但我们自己的代码没有用到这个\u003Ccode\u003EAPI\u003C\u002Fcode\u003E，那么这个\u003Ccode\u003EAPI\u003C\u002Fcode\u003E是不会被叠平的，这会导致我们项目报错。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3\u003E第三方库问题\u003C\u002Fh3\u003E\n\u003Cp\u003E针对\u003Ccode\u003EuseBuiltIns: 'usage'\u003C\u002Fcode\u003E配置的第二点弊端，我们来看这个例子 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fuse-third-party-library-problem\"\u003Euse-third-party-library-problem\u003C\u002Fa\u003E 更直接的感受一下。\u003C\u002Fp\u003E\n\u003Cp\u003E我们把\u003Ccode\u003Etargets\u003C\u002Fcode\u003E设为\u003Ccode\u003EIE 11\u003C\u002Fcode\u003E，我们\u003Cstrong\u003E自己的代码只用\u003Ccode\u003Eincludes\u003C\u002Fcode\u003E这个\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E，然后再用第三方库 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FJamie-Yang\u002Ftars-utils\"\u003Etars-utils\u003C\u002Fa\u003E 的\u003Ccode\u003EoptimizeImage\u003C\u002Fcode\u003E方法，生成一个\u003Ccode\u003EBlob\u003C\u002Fcode\u003E对象（\u003Ca href=\"https:\u002F\u002Fgithub.com\u002FJamie-Yang\u002Ftars-utils\u002Fblob\u002Fmaster\u002Fsrc\u002Fimage\u002Foptimize-image.js\"\u003E里面是用\u003Ccode\u003EPromise\u003C\u002Fcode\u003E实现的\u003C\u002Fa\u003E）。\u003C\u002Fp\u003E\n\u003Cp\u003E我们在\u003Ccode\u003EIE 11\u003C\u002Fcode\u003E跑一下看看：\u003C\u002Fp\u003E\n\u003Cimg src=\"https:\u002F\u002Fp1-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F0610c86ea634439eaf45f0cee60ab0d6~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_15.png\" width=\"100%\" \u002F\u003E\n\u003Cp\u003E通过\u003Ccode\u003EBabel\u003C\u002Fcode\u003E编译后的文件，我们会发现：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E只有我们代码中使用的\u003Ccode\u003Eincludes\u003C\u002Fcode\u003E方法被垫平；\u003C\u002Fli\u003E\n\u003Cli\u003E第三方库中用到的\u003Ccode\u003EPromise\u003C\u002Fcode\u003E并没有被垫平，所以导致\u003Ccode\u003EIE 11\u003C\u002Fcode\u003E报错了。\u003Cstrong\u003E这是一个非常现实的问题。\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E我们在高级一点的浏览器（\u003Ccode\u003Echrome 108\u003C\u002Fcode\u003E）看看：\u003C\u002Fp\u003E\n\u003Cimg src=\"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F27cb9a74aa2c4a5baf90492e025996af~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_16.png\" width=\"70%\" \u002F\u003E\n\u003Cp\u003E在\u003Ccode\u003Echrome 108\u003C\u002Fcode\u003E运行没有任何问题，因为\u003Ccode\u003Echrome 108\u003C\u002Fcode\u003E已经内部实现了\u003Ccode\u003EPromise\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Ch2\u003E总结\u003C\u002Fh2\u003E\n\u003Cp\u003E看到这里，相信我们对\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E的配置功能已经有个大概的了解了。上述所说的问题确实是我们很实际的问题。\u003C\u002Fp\u003E\n\u003Cp\u003E因此，\u003Ccode\u003EuseBuiltIns\u003C\u002Fcode\u003E设置\u003Ccode\u003Eentry\u003C\u002Fcode\u003E还是\u003Ccode\u003Eusage\u003C\u002Fcode\u003E，还是得根据我们项目实际需求来，我个人建议：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E由于我们\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E配置方式，是会把当前\u003Ccode\u003Etargets\u003C\u002Fcode\u003E缺失的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003Cstrong\u003E注入到全局\u003C\u002Fstrong\u003E，所以这个配置方式是比较适合我们做的一些\u003Cstrong\u003E前端工程项目\u003C\u002Fstrong\u003E或者\u003Cstrong\u003E应用程序\u003C\u002Fstrong\u003E。如果对包的体积不是很在意，建议使用\u003Ccode\u003EuseBuiltIns: entry\u003C\u002Fcode\u003E的方式，然后再\u003Ccode\u003Eimport 'core-js\u002Fstable'\u003C\u002Fcode\u003E，一劳永逸的垫平，这样可以帮我们避免掉一些奇怪的问题，\u003C\u002Fli\u003E\n\u003Cli\u003E如果使用\u003Ccode\u003EuseBuiltIns: usage\u003C\u002Fcode\u003E，那还是得注意第三方库的问题。如果判断出哪块\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E缺失，我们可以自己手动\u003Ccode\u003Eimport\u003C\u002Fcode\u003E去垫平\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch1\u003E再谈\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E\u003C\u002Fh1\u003E\n\u003Cp\u003E上面说到，\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E配置方式，是会把当前浏览器缺失的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003Cstrong\u003E注入到全局的\u003C\u002Fstrong\u003E，那么有没有不注入全局的办法呢？答案是有的。它就是我们接下来要讲的\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E配置。\u003C\u002Fp\u003E\n\u003Cp\u003E我们先来看看它有几个配置项（谢天谢地，不算很多）：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F babel.config.js\nconst plugins = [\n    [\n        '@babel\u002Fplugin-transform-runtime',\n        {\n            helpers,\n            regenerator,\n            corejs,\n            \n            version\n        }\n    ]\n];\nmodule.exports = {plugins};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2\u003E\u003Ccode\u003Ehelpers\u003C\u002Fcode\u003E &amp;&amp; \u003Ccode\u003Eregenerator\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Ch3\u003E解析\u003C\u002Fh3\u003E\n\u003Cp\u003E我们先看前两个配置，因为前两个配置比较简单，我们放在一起讲。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Ehelpers\u003C\u002Fcode\u003E默认值是：\u003Ccode\u003Etrue\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eregenerator\u003C\u002Fcode\u003E默认值是：\u003Ccode\u003Etrue\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E通过上篇文章——\u003Ca href=\"https:\u002F\u002Fjuejin.cn\u002Fpost\u002F7190312484492804156#heading-29\"\u003E想弄懂Babel？你必须得先弄清楚这几个包\u003C\u002Fa\u003E，我们知道：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E关于\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E是\u003Cstrong\u003E存放了\u003Ccode\u003EBabel\u003C\u002Fcode\u003E辅助函数的一个集合包\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E关于辅助函数\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E当我们只用了一些\u003Ccode\u003EES6+\u003C\u002Fcode\u003E语法糖的时候，\u003Ccode\u003EBabel\u003C\u002Fcode\u003E编译时会内联注入一些辅助函数\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E与\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E配合使用时，会将我们用到的辅助函数，从\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E中以\u003Ccode\u003Erequire\u003C\u002Fcode\u003E或者\u003Ccode\u003Eimport\u003C\u002Fcode\u003E的方式，引入到我们的文件中，实现复用，从而减小我们最终输出包的体积。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E关于\u003Ccode\u003Eregenerator\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E我们的源码里面使用了\u003Ccode\u003Easync function() {}\u003C\u002Fcode\u003E等异步函数，或者\u003Ccode\u003Efuction* myGenerator() {}\u003C\u002Fcode\u003E这种\u003Ccode\u003EGenerator\u003C\u002Fcode\u003E函数的话，就会需要用到\u003Ccode\u003Eregenerator-runtime\u003C\u002Fcode\u003E这个包来编译。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EBabel &gt;= 7.18.0\u003C\u002Fcode\u003E，\u003Ccode\u003Eregenerator-runtime\u003C\u002Fcode\u003E包里的内容，会以\u003Cstrong\u003E局部变量的方式内联注入到我们的代码中\u003C\u002Fstrong\u003E，这样我们就不需要全局提供一个\u003Ccode\u003EregeneratorRuntime\u003C\u002Fcode\u003E对象。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E例如我们使用了\u003Ccode\u003Eclass\u003C\u002Fcode\u003E语法糖跟\u003Ccode\u003Easync function() {}\u003C\u002Fcode\u003E，然后用\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E跟\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E（默认情况下，\u003Ccode\u003Ehelpers\u003C\u002Fcode\u003E与\u003Ccode\u003Eregenerator\u003C\u002Fcode\u003E值为\u003Ccode\u003Etrue\u003C\u002Fcode\u003E）配合使用，编译后如下图：\n\u003Cimg src=\"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F19a14a8c654a42e6a5d314476d42fafc~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_17.png\"\u003E\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E当我们把\u003Ccode\u003Ehelpers\u003C\u002Fcode\u003E跟\u003Ccode\u003Eregenerator\u003C\u002Fcode\u003E的值设为\u003Ccode\u003Efalse\u003C\u002Fcode\u003E：\n\u003Cimg src=\"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fe5621595b94f4ee895331186348ce00f~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_18.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E我们会发现我们的辅助函数，跟\u003Ccode\u003Eregenerator-runtime\u003C\u002Fcode\u003E这个包又变回了内联方式。所以：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Ehelpers\u003C\u002Fcode\u003E：控制的是我们的辅助函数，\u003Cstrong\u003E是否不内联\u003C\u002Fstrong\u003E进我们的代码中。\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Etrue\u003C\u002Fcode\u003E的话是不内联，而是引用\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E辅助函数集合包\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Efalse\u003C\u002Fcode\u003E的话，则会内联\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eregenerator\u003C\u002Fcode\u003E：与\u003Ccode\u003Ehelpers\u003C\u002Fcode\u003E类似，控制的是我们\u003Ccode\u003Eregenerator-runtime\u003C\u002Fcode\u003E这个包的代码，\u003Cstrong\u003E是否不内联\u003C\u002Fstrong\u003E进我们的代码中。\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Etrue\u003C\u002Fcode\u003E的话是不内联，而是引用\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E辅助函数集合包\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Efalse\u003C\u002Fcode\u003E的话，则会内联\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3\u003E注意\u003C\u002Fh3\u003E\n\u003Cp\u003E官网中关于\u003Ccode\u003Eregenerator\u003C\u002Fcode\u003E的解释，大致意思是：\n\u003Ccode\u003Eregenerator\u003C\u002Fcode\u003E如果设为\u003Ccode\u003Efalse\u003C\u002Fcode\u003E，需要我们提供一个全局的\u003Ccode\u003EregeneratorRuntime\u003C\u002Fcode\u003E的对象。\u003C\u002Fp\u003E\n\u003Cp\u003E但是：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E当\u003Ccode\u003EBabel &gt;= 7.18.0\u003C\u002Fcode\u003E以后，\u003Ccode\u003Eregenerator-runtime\u003C\u002Fcode\u003E包里的内容，会以\u003Cstrong\u003E局部变量的方式内联注入到我们的代码中\u003C\u002Fstrong\u003E。所以其实\u003Ccode\u003EBabel &gt;= 7.18.0\u003C\u002Fcode\u003E \u003Ccode\u003Eregenerator\u003C\u002Fcode\u003E这个配置项个人觉得是基本没用了\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EBabel &lt; 7.18.0\u003C\u002Fcode\u003E的话，则需要我们提供一个全局的\u003Ccode\u003EregeneratorRuntime\u003C\u002Fcode\u003E的对象。相关案例可查看 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fimport-regenerator-runtime\"\u003Eimport-regenerator-runtime\u003C\u002Fa\u003E，开启\u003Ccode\u003Ebabel.config.js\u003C\u002Fcode\u003E相关注释代码。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003E\u003Ccode\u003Ecorejs\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Ch3\u003E解析\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Ccode\u003Ecorejs\u003C\u002Fcode\u003E这个配置项一旦不为\u003Ccode\u003Efalse\u003C\u002Fcode\u003E，就是用来设置我们的要垫平的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，以\u003Cstrong\u003E不污染全局局部变量方式垫平。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E它有三个值：\u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003E值\u003C\u002Fth\u003E\n\u003Cth\u003E对应依赖\u003C\u002Fth\u003E\n\u003Cth\u003E补充\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Ccode\u003Efalse\u003C\u002Fcode\u003E（默认值）\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Ccode\u003E2\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003Ccode\u003E@babel\u002Fruntime-corejs2\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E1. 只能编译支持全局变量（如\u003Ccode\u003EPromise\u003C\u002Fcode\u003E）和静态属性（如\u003Ccode\u003EArray.from\u003C\u002Fcode\u003E）；\u003Cbr\u002F\u003E2. 不能编译实例相关方法（\u003Ccode\u003E[].includes\u003C\u002Fcode\u003E）\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Ccode\u003E3\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003Ccode\u003E@babel\u002Fruntime-corejs3\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E1. 既能编译能编译支持全局变量和静态属性，又能编译实例方法\u003Cbr \u002F\u003E2. 开启\u003Ccode\u003Eproposals: true\u003C\u002Fcode\u003E，还可以编译提案阶段的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\n\u003C\u002Ftable\u003E\n\u003Cp\u003E我们用这个例子 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Ftransform-runtime-config\"\u003Etransform-runtime-config\u003C\u002Fa\u003E 体验一下。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E如果配置的是\u003Ccode\u003Ecorejs: 2\u003C\u002Fcode\u003E的话，会怎么样：\n\u003Cimg src=\"https:\u002F\u002Fp6-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F020f5fdcb1354c3fa9419adef97d038d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_19.png\" width=\"100%\" \u002F\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E我们会发现，实例方法\u003Ccode\u003Eincludes\u003C\u002Fcode\u003E没被垫平，提案\u003Ccode\u003EAPI\u003C\u002Fcode\u003E（\u003Ccode\u003EMath.signbit\u003C\u002Fcode\u003E）也没有被垫平；\u003Ccode\u003EPromise\u003C\u002Fcode\u003E是以局部变量的方式出现在我们的代码中。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E我们再看看配置的是\u003Ccode\u003Ecorejs: {version: 3, proposals: true}\u003C\u002Fcode\u003E：\n\u003Cimg src=\"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F48195d3d1e554981989caf0276adf644~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_20.png\" width=\"100%\" \u002F\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E我们会发现，实例方法\u003Ccode\u003Eincludes\u003C\u002Fcode\u003E被垫平，提案\u003Ccode\u003EAPI\u003C\u002Fcode\u003E（\u003Ccode\u003EMath.signbit\u003C\u002Fcode\u003E）也垫平；但它们都以\u003Cstrong\u003E局部变量\u003C\u002Fstrong\u003E的方式注入。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E所以，如果我们不想以全局的方式污染的方式垫平我们的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，我们\u003Ccode\u003Ecorejs\u003C\u002Fcode\u003E就不能为\u003Ccode\u003Efalse\u003C\u002Fcode\u003E，并且优先使用\u003Ccode\u003E@babel\u002Fruntime-corejs3\u003C\u002Fcode\u003E这个包来垫平\u003C\u002Fstrong\u003E（设置为\u003Ccode\u003E3\u003C\u002Fcode\u003E）\u003C\u002Fp\u003E\n\u003Ch3\u003E优化\u003C\u002Fh3\u003E\n\u003Cp\u003E上面的案例我们并没有设置\u003Ccode\u003Etargets\u003C\u002Fcode\u003E，所以\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E配置下，会把我们代码中用到的\u003Cstrong\u003E所有\u003C\u002Fstrong\u003E\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E都垫平。我们来设置\u003Ccode\u003Etargets\u003C\u002Fcode\u003E，看看能不能垫平我们的\u003Ccode\u003Etargets\u003C\u002Fcode\u003E不支持的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E我们在\u003Ccode\u003Epackage.json\u003C\u002Fcode\u003E里面添加，或者在\u003Cstrong\u003E配置文件的顶层\u003C\u002Fstrong\u003E添加是可以的（\u003Cstrong\u003E经过测试，在\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E里面设置\u003Ccode\u003Etargets\u003C\u002Fcode\u003E是不行的\u003C\u002Fstrong\u003E）：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u002F\u002F package.json\n&quot;browserslist&quot;: [\n    &quot;chrome 80&quot;\n]\n\n\u002F\u002F 或者在顶层添加\nmodule.exports = {\n    targets: {chrome: 80}, \u002F\u002F 在这里添加\n    presets: ['@babel\u002Fpreset-env'],\n    plugins: [\n        [\n            &quot;@babel\u002Fplugin-transform-runtime&quot;,\n            {\n                ...\n            }\n        ]\n    ]\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E输出：\n\u003Cimg src=\"https:\u002F\u002Fp6-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F90045fe897b94165be2574b609b2d727~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_21.png\" width=\"100%\" \u002F\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E我们会发现，\u003Ccode\u003EPromise\u003C\u002Fcode\u003E跟\u003Ccode\u003Eincludes\u003C\u002Fcode\u003E都没有被垫平，因为\u003Ccode\u003Echrome 80\u003C\u002Fcode\u003E已经支持了\u003C\u002Fp\u003E\n\u003Ch3\u003E总结\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E是以全局方式垫平，\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E是以局部变量方式垫平，两者我们应该选择其一，不要又用\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E配置方式，又用\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E配置方式，这样肯定会出现一些奇奇怪怪的问题。\u003C\u002Fli\u003E\n\u003Cli\u003E因为使用\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E垫平是以\u003Cstrong\u003E局部变量的方式\u003C\u002Fstrong\u003E来垫平，所以\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E这种配置方式更适合来做 \u003Cstrong\u003E库\u003C\u002Fstrong\u003E 的开发。它可以很好的帮我们的库与使用者的项目解耦。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E参考文章：\u003Ca href=\"https:\u002F\u002Fbabel.dev\u002Fdocs\u002Fen\u002Fbabel-plugin-transform-runtime\"\u003Ebabel-plugin-transform-runtime\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch2\u003E其他\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E案例 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fpreset-env-useBuiltIns-config\"\u003Epreset-env-useBuiltIns-config\u003C\u002Fa\u003E 里面有个\u003Ccode\u003Estage-1\u003C\u002Fcode\u003E阶段的提案\u003Ccode\u003EAPI\u003C\u002Fcode\u003E—— \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ftc39\u002Fproposal-array-last\"\u003EArray.prototype.lastItem\u003C\u002Fa\u003E（取数组最后一项）。本来是想用\u003Ccode\u003EArray.prototype.uniqueBy\u003C\u002Fcode\u003E这个当前处在\u003Ccode\u003Estage-1\u003C\u002Fcode\u003E的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E来给大家做例子的，结果发现编译以后在\u003Ccode\u003EIE 11\u003C\u002Fcode\u003E有问题。所以给\u003Ccode\u003EBabel\u003C\u002Fcode\u003E提了个 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel\u002Fissues\u002F15392\"\u003Eissues\u003C\u002Fa\u003E ：\u003C\u002Fp\u003E\n  \u003Cimg src=\"https:\u002F\u002Fp1-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F940627842070482b8fa70558683b0afe~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_22.png\" width=\"80%\" \u002F\u003E\n\u003Cp\u003E目前应该是修复了，在等合并。复现问题的代码包在 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Fbabel-use-proposals-problem\"\u003Ebabel-use-proposals-problem\u003C\u002Fa\u003E，感兴趣的朋友也可以\u003Ccode\u003EFork\u003C\u002Fcode\u003E自己瞅瞅。说这个事主要也是想表达，学习还是不能停止（不是卷啊，还是要有学习的习惯）。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E在讲\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E如何配置时，我们说到开启\u003Ccode\u003E{version: 3, proposals: true}\u003C\u002Fcode\u003E时，可以以局部变量的方式对提案阶段的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E垫平。\u003C\u002Fp\u003E\n\u003Cp\u003E但是经过测试发现，有些提案阶段的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E，用这个方法似乎是不能按预期实现的，所以又提了个 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel\u002Fissues\u002F15412\"\u003Eissues\u003C\u002Fa\u003E ，有个\u003Ccode\u003EBabel\u003C\u002Fcode\u003E之一的大佬说可以用\u003Ccode\u003Ebabel-plugin-polyfill-corejs3\u003C\u002Fcode\u003E来实现：\u003C\u002Fp\u003E\n  \u003Cimg src=\"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fd5b08cdd2f614f15ae09ace5e69962d1~tplv-k3u1fbpfcp-watermark.image?\" alt=\"pic_23.png\" width=\"80%\" \u002F\u003E\n\u003Cp\u003E关于\u003Ccode\u003Ebabel-plugin-polyfill-corejs3\u003C\u002Fcode\u003E这块，其实\u003Ccode\u003EBabel\u003C\u002Fcode\u003E还有一种垫平配置方式，是使用 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel-polyfills\"\u003Ebabel-polyfills\u003C\u002Fa\u003E 这个包来实现的，这块后期再看看要不要出文章聊聊。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003E最后\u003C\u002Fh2\u003E\n\u003Cp\u003E通过以上的了解，我们最后来总结一下这个配置。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E如果我们开发的项目是\u003Cstrong\u003E应用程序\u003C\u002Fstrong\u003E，或者\u003Cstrong\u003E大型的项目\u003C\u002Fstrong\u003E，那我们可以这么配置：\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F Babel配置\nconst presets = [\n    [\n        '@babel\u002Fpreset-env',\n        {\n            modules: false,\n\n            \u002F\u002F 或者只想用垫平我们代码中用到的 --&gt; useBuiltIns: 'usage',\n            useBuiltIns: 'entry',\n            corejs: {\n                version: '3.27.2',\n                proposals: true\n            }\n        }\n    ]\n];\nconst plugins = [\n    '@babel\u002Fplugin-transform-runtime'\n];\nmodule.exports = {plugins, presets};\n\n\u002F\u002F package.json\n{\n    ...,\n    \u002F\u002F 设置目标环境\n    &quot;browserslist&quot;: [\n        &quot;ie 11&quot;\n    ]\n}\n\n\u002F\u002F 入口文件\n\u002F\u002F ---- useBuiltIns: 'entry'时，需要引入以下----\n\u002F\u002F 垫平全部ES6+稳定版API\nimport 'core-js\u002Fstable'; \n\u002F\u002F ---- 或者 -----\n\u002F\u002F 垫平所有ES6+ API，包括提案阶段\nimport 'core-js';\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Chr\u003E\n\u003Cul\u003E\n\u003Cli\u003E如果我们是想开发一个\u003Cstrong\u003E第三方库\u003C\u002Fstrong\u003E，我们可以这么配置：\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F Babel配置\nconst presets = [\n    [\n        '@babel\u002Fpreset-env',\n        {\n            modules: false\n        }\n    ]\n];\nconst plugins = [\n    [\n        '@babel\u002Fplugin-transform-runtime',\n        {\n            corejs: {\n                version: 3,\n                proposals: true\n            }\n        }\n    ]\n];\nmodule.exports = {plugins, presets};\n\n\u002F\u002F package.json\n{\n    ...,\n    \u002F\u002F 设置目标环境\n    &quot;browserslist&quot;: [\n        &quot;ie 11&quot;\n    ]\n}\n\n\u002F\u002F 入口文件\nconst Method = {\n    wait(delay) {\n        return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(), delay);\n    }\n}\n...\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E文章涉及到的例子，已经上传 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\"\u003EGithub\u003C\u002Fa\u003E，觉得有帮助的话，欢迎\u003Ccode\u003EStar\u003C\u002Fcode\u003E或者\u003Ccode\u003EFork\u003C\u002Fcode\u003E学习。\u003C\u002Fp\u003E\n\u003Cp\u003E如果读完这篇文章的你，觉得真的有帮助到，\u003Cstrong\u003E欢迎点赞收藏\u003C\u002Fstrong\u003E；如果有异同点，\u003Cstrong\u003E欢迎在评论区讨论\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n"}}],fetch:{},mutations:[]});