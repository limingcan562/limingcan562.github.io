__NUXT_JSONP__("/posts/about-prototype", {data:[{posts:{attributes:{title:"关于原型链的问题，教你怎么套用方法直接判断，面试不再虚",des:"__proto__、prototype、constructor到底是什么？带你一步步搞明白",createTime:"2022-3-14"},html:"\u003Ch2\u003E关于原型链的问题，教你怎么套用方法直接判断，面试不再虚\u003C\u002Fh2\u003E\n\u003Ch3\u003E前言\u003C\u002Fh3\u003E\n\u003Cp\u003E首先原型、原型链，算是前端进阶里面必不可少，十分重要的一块了。由于这块特别绕，所以面试官很喜欢用这一块来辨别你的底层知识掌握的怎么样。用的第三方框架，库里面，很多功能模块化了，但大部分功能都继承自一个基类。既然涉及到继承，那也必不可少得先了解原型链，所以原型链确实重中之重。\u003C\u002Fp\u003E\n\u003Ch3\u003E为什么大家对原型，原型链子会感到“懵”跟“绕”\u003C\u002Fh3\u003E\n\u003Cp\u003E其本质是因为，\u003Cstrong\u003E大家都没理清楚\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E、\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E三者的联系\u003C\u002Fstrong\u003E。所以很多人在看这一块知识的时候，刚开头看可能还能理解，看久了就懵了，因为代码中充斥着各种\u003Ccode\u003Ex.__proto__.__proto__\u003C\u002Fcode\u003E，\u003Ccode\u003Ex.__proto__.constructor.prototype\u003C\u002Fcode\u003E，\u003Ccode\u003Ex.prototype.__proto__\u003C\u002Fcode\u003E等等，这当然会懵掉。所以我们要理解原型、原型链是什么，一定要先搞明白，\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E、\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E这三个到底是个什么东西，再弄明白它们三个是什么联系。\u003C\u002Fp\u003E\n\u003Cp\u003E下面我会用比较通俗的话来解释，带着大家更好的理解原型，原型链是什么（因为为了大家更好的理解，所以有些地方可能会稍微有点不恰当，敬请见谅）。\u003C\u002Fp\u003E\n\u003Cp\u003E为了更好的理解，我们用以下变量作为例子跟话术：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003EPeople\u003C\u002Fcode\u003E为构造函数\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eperson\u003C\u002Fcode\u003E为由\u003Ccode\u003EPeople\u003C\u002Fcode\u003E实例出来的一个对象\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EObject\u003C\u002Fcode\u003E为构造所有对象的顶级基类构造函数\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EFunction\u003C\u002Fcode\u003E为构造所有函数的顶级基类构造函数\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3\u003E\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003E这个属性可以通俗的理解成，\u003Cstrong\u003E所有对象都拥有的一个私有属性（函数也是一种特殊的对象，所以构造函数也会有这个属性）\u003C\u002Fstrong\u003E。所以我们会看到\u003Ccode\u003Eperson.__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003EPeople.prototype.__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003EPeople.__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003EObject.__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003EFunction.__proto__\u003C\u002Fcode\u003E等描述。\u003C\u002Fp\u003E\n\u003Ch3\u003E\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003E这个属性可以通俗的理解成，\u003Cstrong\u003E专属于函数自身的一个属性（可用\u003Ccode\u003EhasOwnProperty\u003C\u002Fcode\u003E验证）\u003C\u002Fstrong\u003E，所以实例出来的对象不会有，只有\u003Cstrong\u003E函数、构造函数\u003C\u002Fstrong\u003E会有。我们通常都会把\u003Ccode\u003E构造函数.prototype\u003C\u002Fcode\u003E看做一个整体，它代表的是，这个函数的\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E里，所有的属性方法等（\u003Ccode\u003EPeople.prototype\u003C\u002Fcode\u003E代表\u003Ccode\u003EPeople.prototype\u003C\u002Fcode\u003E这个\u003Cstrong\u003E整体\u003C\u002Fstrong\u003E里，所有的属性与方法）。所以我们会看到\u003Ccode\u003Eperson.__proto__.prototype\u003C\u002Fcode\u003E、\u003Ccode\u003EPeople.prototype\u003C\u002Fcode\u003E、\u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E、\u003Ccode\u003EFunction.prototype\u003C\u002Fcode\u003E等描述，但一定不会看到\u003Ccode\u003E实例.prototype\u003C\u002Fcode\u003E（\u003Ccode\u003Eperson.prototype\u003C\u002Fcode\u003E）。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E例外：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E箭头函数没有\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E，箭头函数也不能拿来做构造函数\u003C\u002Fli\u003E\n\u003Cli\u003E使用\u003Ccode\u003Ebind\u003C\u002Fcode\u003E方法创造出来的副本函数也没有\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E这两个是例外，大家记得就好，但不影响我们的理解。\u003C\u002Fp\u003E\n\u003Ch3\u003E\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003E这个属性也可以通俗的理解成，\u003Cstrong\u003E所有对象都拥有的一个属性\u003C\u002Fstrong\u003E。可以用\u003Ccode\u003E对象.constructor.name\u003C\u002Fcode\u003E来查看当前构造函数的名字是什么（\u003Ccode\u003Eperson.constructor.name\u003C\u002Fcode\u003E返回\u003Ccode\u003EPeople\u003C\u002Fcode\u003E，因为\u003Ccode\u003Eperson\u003C\u002Fcode\u003E由\u003Ccode\u003EPeople\u003C\u002Fcode\u003E构造实例而来）。所以我们也会看到\u003Ccode\u003Eperson.constructor\u003C\u002Fcode\u003E、\u003Ccode\u003EPeople.prototype.constructor\u003C\u002Fcode\u003E、\u003Ccode\u003EPeople.constructor\u003C\u002Fcode\u003E等描述。\u003C\u002Fp\u003E\n\u003Cp\u003Eok，介绍完这三个属性，我们再来看看这三者有什么联系。\u003C\u002Fp\u003E\n\u003Ch3\u003E\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E、\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E这三者到底是什么联系\u003C\u002Fh3\u003E\n\u003Cp\u003E我们看看下面例子：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F 定义一个People构造函数\nfunction People () {\n\n}\n\n\u002F\u002F 实例化一个person对象\nconst person = new People();\n\n\u002F\u002F 打印true --&gt; 说明实例的__proto__与实例的构造函数的prototype相等\nconsole.log(person.__proto__ === People.prototype); \n\n\u002F\u002F 打印true --&gt; 说明constructor是构造函数的prototype里“自身”的一个属性\nconsole.log(People.prototype.hasOwnProperty('constructor'));\n\n\u002F\u002F 打印true --&gt; 说明非顶级构造函数的prototype.constructor指回这个构造函数本身\nconsole.log(People.prototype.constructor === People);\n\n\u002F\u002F 打印true --&gt; 说明实例的__proto__.constructor 就是 构造函数的prototype.constructor（由第一个打印可知person.__proto__ = People.prototype）\nconsole.log(person.__proto__.constructor === People.prototype.constructor);\n\n\u002F\u002F 打印People --&gt; 说明实例的constructor指向的就是实例的构造函数\nconsole.log(person.constructor.name);\n\n\u002F\u002F 打印fale --&gt; 说明实例自身是没有的constructor属性的\nconsole.log(person.hasOwnProperty('constructor'));\n\n\u002F\u002F 打印true, true --&gt; 说明实例自身是没有的constructor属性的\n\u002F\u002F 它是继承自实例的__proto__.constructor，即实例的构造函数的prototype.constructor\nconsole.log(person.constructor === person.__proto__.constructor, person.constructor === People.prototype.constructor);\n\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E解析：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E跟\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E是什么联系：\u003Cbr\u003E\n如果有一个实例，它是由一个构造函数实例而来，那么这个实例的\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E一定指向这个构造函数的\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E，即\u003Ccode\u003Eperson.__proto__ = People.prototype\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E跟\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E是什么联系：\u003Cbr\u003E\n\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E就是某个普通构造函数的\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E\u003Cstrong\u003E自身\u003C\u002Fstrong\u003E的一个属性（用\u003Ccode\u003EhasOwnProperty\u003C\u002Fcode\u003E可验证），它指向的就是这个构造函数本身，即\u003Ccode\u003EPeople.prototype.constructor = People\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E跟\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E是什么联系：\u003Cbr\u003E\n\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E跟\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E的联系跟\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E与\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E的联系一样。因为以\u003Ccode\u003E.__proto__\u003C\u002Fcode\u003E结尾的，它最后一定\u003Cstrong\u003E指向某个构造函数的原型对象（\u003Ccode\u003EPeople.prototype\u003C\u002Fcode\u003E）\u003C\u002Fstrong\u003E，然后又由于\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E是某个构造函数的\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E\u003Cstrong\u003E自身\u003C\u002Fstrong\u003E的一个属性，因此我们可以这么看：\u003Ccode\u003Eperson.__proto__.constructor = People.prototype.constructor\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003Eok，看到这里，大家可以先暂停一下，整理一下思路。理一理什么是\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E、\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E；然后再理一理\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E、\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E这三者之间的联系。然后接下来进入最让我们蒙圈的东西——原型链。\u003C\u002Fp\u003E\n\u003Ch3\u003E什么是原型链\u003C\u002Fh3\u003E\n\u003Cp\u003E当我们用构造函数\u003Ccode\u003EPeople\u003C\u002Fcode\u003E实例化了一个对象\u003Ccode\u003Eperson\u003C\u002Fcode\u003E后，访问\u003Ccode\u003Eperson\u003C\u002Fcode\u003E的方法或者属性时，会先在实例\u003Ccode\u003Eperson\u003C\u002Fcode\u003E\u003Cstrong\u003E自身\u003C\u002Fstrong\u003E找有没有对应的方法属性。有值的话，则返回值，没有的话则去\u003Ccode\u003Eperson.__proto__\u003C\u002Fcode\u003E（\u003Ccode\u003EPeople.prototype\u003C\u002Fcode\u003E）里找；有值的话，则返回值，没有的话，又会去\u003Ccode\u003EPeople.prototype.__proto__\u003C\u002Fcode\u003E（\u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E）里找。有值的话，则返回值；没有的话，又会去\u003Ccode\u003EObject.prototype._proto__\u003C\u002Fcode\u003E里找，但是\u003Ccode\u003EObject.prototype.__proto__\u003C\u002Fcode\u003E返回\u003Ccode\u003Enull\u003C\u002Fcode\u003E，原型链到顶，一条条原型链搜索完毕，都没有，则返回\u003Ccode\u003Eundefined\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E在查找的过程中会遍历以上的一条链，这条链就是原型链\u003C\u002Fstrong\u003E。上述的过程可以这么看（这个过程也是实现继承的核心）：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"..\u002Fmd\u002Fabout-prototype\u002Fpic_1.png\" alt=\"原型链查找过程\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E经过上述的知识点，相信大家对原型链应该有个基本的认识里吧，现在我们来总结一下，看看有没有什么方法规律。\u003C\u002Fp\u003E\n\u003Ch3\u003E方法总结\u003C\u002Fh3\u003E\n\u003Cp\u003E在看到一堆类似\u003Ccode\u003E.__proto__.__proto__.__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003E.__proto__.__proto__.prototype\u003C\u002Fcode\u003E、\u003Ccode\u003E.__proto__.prototype.consturtor\u003C\u002Fcode\u003E什么的，先不要慌。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E思想步骤：\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Col\u003E\n\u003Cli\u003E我们直接看最后一个属性，看看是以什么结尾\u003C\u002Fli\u003E\n\u003Cli\u003E然后再一步步反推前面调用的都是什么对象\u003C\u002Fli\u003E\n\u003Cli\u003E最后再推出它具体返回值的是什么\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E规律：\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Col\u003E\n\u003Cli\u003E\n\u003Cp\u003E如果最后以\u003Ccode\u003E.__proto__\u003C\u002Fcode\u003E结尾，它最后返回的一定是某个构造函数的\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E（\u003Ccode\u003EObject.prototype.__proto__\u003C\u002Fcode\u003E除外，它到顶了，是原型链的顶端，返回\u003Ccode\u003Enull\u003C\u002Fcode\u003E）\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E如果是以\u003Ccode\u003E.prototype\u003C\u002Fcode\u003E结尾，那么它前面一定是个构造函数，因为只有函数才会有\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E属性（因为一般以\u003Ccode\u003E.prototype\u003C\u002Fcode\u003E结尾返回的都是这个构造函数的\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E所有的方法与属性，所以题目很少会以\u003Ccode\u003E.prototype\u003C\u002Fcode\u003E结尾）\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E如果是以\u003Ccode\u003E.constructor\u003C\u002Fcode\u003E结尾，先弄清楚前面是什么\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E如果前面是\u003Cstrong\u003E实例\u003C\u002Fstrong\u003E，那它直接返回创造实例的那个构造函数；\u003C\u002Fli\u003E\n\u003Cli\u003E如果前面\u003Cstrong\u003E直接是顶级基类构造函数\u003C\u002Fstrong\u003E（\u003Ccode\u003EFunction.constructor\u003C\u002Fcode\u003E）或者\u003Cstrong\u003E直接是普通构造函数\u003C\u002Fstrong\u003E（\u003Ccode\u003EPeople.constructor\u003C\u002Fcode\u003E），它会直接指向\u003Cstrong\u003E构造所有函数的顶级基类构造函数\u003C\u002Fstrong\u003E\u003Ccode\u003EFunction\u003C\u002Fcode\u003E（所有构造函数都是函数，都由顶级构造函数\u003Ccode\u003EFunction\u003C\u002Fcode\u003E而来，所以\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E当然指向它；\u003C\u002Fli\u003E\n\u003Cli\u003E如果前面是\u003Cstrong\u003E非顶级构造函数（普通函数）的原型对象\u003C\u002Fstrong\u003E（\u003Ccode\u003EPeople.prototype.constructor\u003C\u002Fcode\u003E），因为实例的\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E是继承自\u003Ccode\u003E普通构造函数.prototype.constructor\u003C\u002Fcode\u003E，所以\u003Ccode\u003E普通构造函数.prototype.constructor\u003C\u002Fcode\u003E必须指回它自己，（\u003Ccode\u003E普通构造函数.prototype.constructor = 普通构造函数\u003C\u002Fcode\u003E）。针对这点，我们看看它是怎么继承来的。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E整个继承的流程是：在实例\u003Ccode\u003Eperson\u003C\u002Fcode\u003E本身查找，找不到去\u003Ccode\u003Eperson.__proto__\u003C\u002Fcode\u003E（\u003Ccode\u003EPeople.prototype\u003C\u002Fcode\u003E）找，发现有\u003Ccode\u003EPeople.prototype.constructor\u003C\u002Fcode\u003E，并且\u003Ccode\u003EPeople.prototype.constructor = People\u003C\u002Fcode\u003E返回它，所以\u003Ccode\u003Eperson.constructor = People\u003C\u002Fcode\u003E。\n流程如图所示：\u003Cbr\u003E\n\u003Cimg src=\"..\u002Fmd\u002Fabout-prototype\u002Fpic_2.png\" alt=\"原型链图\"\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003Eok，经过上面总结出的思想步骤跟规律，我们来试试：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F 定义一个People构造函数\nfunction People() {\n\n}\n\n\u002F\u002F 实例化一个person对象\nconst person = new People();\n\n\u002F\u002F 第一题\nconsole.log(People.__proto__);\n\n\u002F\u002F 第二题\nconsole.log(People.constructor);\n\n\u002F\u002F 第三题\nconsole.log(person.prototype);\n\n\u002F\u002F 第四题\nconsole.log(person.__proto__.__proto__);\n\n\u002F\u002F 第五题\nconsole.log(People.__proto__.prototype);\n\n\u002F\u002F 第六题\nconsole.log(person.__proto__.__proto__.constructor);\n\n\u002F\u002F 第七题\nconsole.log(Object.__proto__);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E我们以第一道题为例，解析一下：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E先看是以什么结尾。以\u003Ccode\u003E.__proto__\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003Eok，心里有个大概了，根据规律总结第一点，它肯定返回某个构造函数的\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E再反推一下前面调用的都是什么对象。前面是\u003Ccode\u003EPeople\u003C\u002Fcode\u003E，\u003Ccode\u003EPeople\u003C\u002Fcode\u003E是什么？是构造函数，函数都有一个顶级基类构造函数，那就是\u003Ccode\u003EFunction\u003C\u002Fcode\u003E，所以\u003Ccode\u003EPeople.__proto__\u003C\u002Fcode\u003E返回的就是\u003Ccode\u003EFunction.prototype\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E我们以第二道题为例，解析一下：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E先看是以什么结尾。以\u003Ccode\u003E.constructor\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E调用对象直接是普通构造函数，根据规律总结第三点的第二小点，直接得出\u003Ccode\u003EFunction\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E我们再以第六道题为例，解析一下：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E先看是以什么结尾。以\u003Ccode\u003E.constructor\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E再反推一下前面是调用的都是什么对象。先看\u003Ccode\u003Eperson.__proto__\u003C\u002Fcode\u003E，返回的是\u003Ccode\u003EPeople.prototype\u003C\u002Fcode\u003E，那这题就变成了\u003Ccode\u003EPeople.prototype.__proto__.constructor\u003C\u002Fcode\u003E。再继续看，\u003Ccode\u003EPeople.prototype.__proto__\u003C\u002Fcode\u003E返回的是什么，\u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E，那这题实际就是\u003Ccode\u003EObject.prototype.constructor\u003C\u002Fcode\u003E。根据规律总结第三点的第三小点，那它返回的就是\u003Ccode\u003EObject\u003C\u002Fcode\u003E本身。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E大家一定要注意，\u003Ccode\u003EObject.__proto__\u003C\u002Fcode\u003E跟\u003Ccode\u003EFunction.__proto__\u003C\u002Fcode\u003E，\u003Ccode\u003EObject\u003C\u002Fcode\u003E跟\u003Ccode\u003EFunction\u003C\u002Fcode\u003E都是顶级构造函数，所以\u003Ccode\u003EObject.__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003EFunction.__proto__\u003C\u002Fcode\u003E返回的都是\u003Ccode\u003EFunction.prototype\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch3\u003E牛刀小试\u003C\u002Fh3\u003E\n\u003Cp\u003E根据上面对\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E、\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E的特点总结，还有方法总结，我们可以拿下面这道题来试试，如果大家都可以正确无误的答出来，那大家对原型应该就了解的差不多了\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Efunction Person(name) {\n    this.name = name\n}\nvar p2 = new Person('king');\n\nconsole.log(p2.__proto__); \u002F\u002F Person.prototype\n\nconsole.log(p2.__proto__.__proto__); \u002F\u002F Object.prototype\n\nconsole.log(p2.__proto__.__proto__.__proto__); \u002F\u002F null\n\nconsole.log(p2.__proto__.__proto__.__proto__.__proto__); \u002F\u002F 报错\n\nconsole.log(p2.constructor); \u002F\u002F Person\n\nconsole.log(p2.prototype); \u002F\u002F undefined\n\nconsole.log(Person.constructor); \u002F\u002F Function\n\nconsole.log(Person.prototype); \u002F\u002F 输出Person.prototype这个对象里所有的方法和属性\n\nconsole.log(Person.prototype.constructor); \u002F\u002F Person\n\nconsole.log(Person.prototype.__proto__); \u002F\u002F Obejct.prototype\n\nconsole.log(Person.__proto__); \u002F\u002F Fuction.prototype\n\nconsole.log(Function.prototype.__proto__); \u002F\u002F Obeject.prototype\n\nconsole.log(Function.__proto__); \u002F\u002F Function.prototype\n\nconsole.log(Object.__proto__); \u002F\u002F Function.prototype\n\nconsole.log(Object.prototype.__proto__); \u002F\u002F null\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3\u003E最后\u003C\u002Fh3\u003E\n\u003Cp\u003E原型、原型链本来就挺绕的，所以大家先了解\u003Ccode\u003E__proto__\u003C\u002Fcode\u003E、\u003Ccode\u003Eprototype\u003C\u002Fcode\u003E、\u003Ccode\u003Econstructor\u003C\u002Fcode\u003E是什么，再明白它们之间的是什么联系，循环渐进。等理解以后，多画几遍原型链图加深理解。OK，最后祭出一张原型链图：\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cstrong\u003E红色链表示的就是实例\u003Ccode\u003Eperson\u003C\u002Fcode\u003E原型链\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E\u003Cimg src=\"..\u002Fmd\u002Fabout-prototype\u002Fpic_3.png\" alt=\"原型链图\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E写着写着，发现又写了一大堆，希望能够帮助到大家。如果觉得觉得写得好的，有帮助到的，欢迎大家点赞，也欢迎大家评论交流。\u003C\u002Fp\u003E\n\u003Cp\u003E既然明白了什么是原型链，那还不赶紧趁热打铁，进阶看看什么是\u003Ca href=\"https:\u002F\u002Flimingcan562.github.io\u002Fposts\u002Fjs-inherit\"\u003EJS继承\u003C\u002Fa\u003E吧！\u003C\u002Fp\u003E\n"}}],fetch:{},mutations:[]});