__NUXT_JSONP__("/posts/babel-new-config", {data:[{posts:{attributes:{title:"Babel”新的配置方法“，你知道吗？",des:"新的配置方法，更加简便，更加强大",createTime:"2023-5-22"},html:"\u003Ch1\u003E前言\u003C\u002Fh1\u003E\n\u003Cp\u003E在上一篇文章——\u003Ca href=\"https:\u002F\u002Fjuejin.cn\u002Fpost\u002F7197666704435920957\"\u003EBabel配置不要再“复制粘贴”了，带你自己配一个Babel\u003C\u002Fa\u003E 中，我们知道：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E如果我们开发的项目是\u003Cstrong\u003E应用程序\u003C\u002Fstrong\u003E，或者\u003Cstrong\u003E大型的项目\u003C\u002Fstrong\u003E，我们可以利用\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E的配置功能，对\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E进行\u003Cstrong\u003E全局垫平\u003C\u002Fstrong\u003E。所以我们一般这么配置：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u002F\u002F babel.config.js\nconst presets = [\n    [\n        '@babel\u002Fpreset-env',\n        {\n            modules: false,\n            useBuiltIns: 'entry', \u002F\u002F 或者 useBuiltIns: 'usage'\n            corejs: { version: '3.27.2', proposals: true }\n        }\n    ]\n];\n\nconst plugins = [\n    '@babel\u002Fplugin-transform-runtime'\n]\nmodule.exports = {plugins, presets};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E如果我们是想开发一个\u003Cstrong\u003E第三方库\u003C\u002Fstrong\u003E，我们可以利用\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E的配置功能，对\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E进行\u003Cstrong\u003E局部垫平\u003C\u002Fstrong\u003E，而不影响全局的环境。所以我们一般这么配置：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u002F\u002F babel.confing.js\nconst presets = [\n    [\n        '@babel\u002Fpreset-env',\n        { modules: false }\n    ]\n];\nconst plugins = [\n    [\n        '@babel\u002Fplugin-transform-runtime',\n        {\n            corejs: {\n                version: 3,\n                proposals: true\n            }\n        }\n    ]\n];\nmodule.exports = {plugins, presets};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E以上是我们平时关于\u003Ccode\u003EBabel\u003C\u002Fcode\u003E见得最多的配置方法。但是这么配：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E有时我们要关注\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E配置，有时又要关注\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E配置，并且配置项那么多，这种配置方法其实还是挺\u003Cstrong\u003E繁琐\u003C\u002Fstrong\u003E的\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EBabel\u003C\u002Fcode\u003E内容知识点本来就十分多，如果我们本身对\u003Ccode\u003EBabel\u003C\u002Fcode\u003E就“懵懵懂懂”的话，这无疑会很容易加深我们对\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的疑惑，让我们觉得更懵圈。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E但其实还有一种新的\u003Ccode\u003EBabel\u003C\u002Fcode\u003E配置方法，它既能实现以上的配置，配置起来更加简洁，并且功能比上面的配置还要强大，同时它也是\u003Ccode\u003EBabel\u003C\u002Fcode\u003E成员更推荐的配法\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E学习是个循序渐进的过程，所以这篇文章接下来会带大家：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E大致了解这种新的配置方法一些背景故事，为什么诞生\u003C\u002Fli\u003E\n\u003Cli\u003E了解这种新的配置方法如何配置\u003C\u002Fli\u003E\n\u003Cli\u003E答疑以前我们学习关于\u003Ccode\u003EBabel\u003C\u002Fcode\u003E配置的疑问\u003C\u002Fli\u003E\n\u003Cli\u003E目前新配置方法存在的问题\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003EPS：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E为了大家阅读方便，每个模块相对独立，大家可以挑选自己喜欢的模块阅读\u003C\u002Fli\u003E\n\u003Cli\u003E想直接看怎么用的朋友，可以直接跳到\u003Cstrong\u003E使用模块\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch1\u003E特别说明\u003C\u002Fh1\u003E\n\u003Cp\u003E本着写文章注重质量跟严谨性的态度，也为了大家可以更放心的使用这个新的配置方法，因此这个新的配置方法，我也阅读了大量关于\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的文章，也在\u003Ccode\u003Egithub\u003C\u002Fcode\u003E上提了一些\u003Ccode\u003Eissues\u003C\u002Fcode\u003E向\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的开发成员求证学习。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的开发成员也十分友好，回应了我说：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E新的配置方法文档由两部分组成\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E目前这个新的配置方法是他们更推荐的配法，完全可以用来替换\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E、\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E这两个包的配置功能\u003C\u002Fstrong\u003E，达到一样的配置效果\u003C\u002Fli\u003E\n\u003Cli\u003E新的配置方法有一个对应的包，这个包在\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E内部也稳定使用了\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E详细的可以看看我在\u003Ccode\u003EBabel\u003C\u002Fcode\u003E提的\u003Ccode\u003Eissues\u003C\u002Fcode\u003E：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F758041bbbfba4057b170b216d2e88cc9~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F9c9eb36eec294327a548c82f3d843efd~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Eissues\u003C\u002Fcode\u003E链接：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel\u002Fissues\u002F15412#issuecomment-1518289649\"\u003ESome of the proposed methods do not seem to have been realised\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel\u002Fissues\u002F15596#issuecomment-1528698891\"\u003EThe &quot;useBuiltIns: usage&quot; mode and &quot;usage-global&quot; mode have different output codes\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E目前\u003Ccode\u003EBabel\u003C\u002Fcode\u003E官网并没有对这个新的配置方法有更详细的说明，相信后续这个方法可能也会成为\u003Ccode\u003EBabel\u003C\u002Fcode\u003E配置的主流。因此，大家学习到这种方法，也算是对\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的一种拓展，但是最重要的是\u003Cstrong\u003E我们可以利用这个新的方法，更方便的配置我们的\u003Ccode\u003EBabel\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E毕竟得到了官方\u003Ccode\u003EBabel\u003C\u002Fcode\u003E开发成员的回答与肯定，所以\u003Cstrong\u003E这个新的配置方法，大家是可以放心“食用”的\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n\u003Ch1\u003E准备\u003C\u002Fh1\u003E\n\u003Cp\u003E在文章开始之前，如果你对\u003Ccode\u003EBabel\u003C\u002Fcode\u003E已经有一个系统的了解，也明白\u003Ccode\u003EBabel\u003C\u002Fcode\u003E怎么配置，那么这篇文章会让你学习到\u003Ccode\u003EBabel\u003C\u002Fcode\u003E一种更强大的新的配置方法；\u003C\u002Fp\u003E\n\u003Cp\u003E但是如果你才刚接触\u003Ccode\u003EBabel\u003C\u002Fcode\u003E，或者对\u003Ccode\u003EBabel\u003C\u002Fcode\u003E似懂非懂，还处于迷迷糊糊的状态，那我还是强烈建议你先阅读之前的两篇文章（\u003Cstrong\u003E尤其是第二篇\u003C\u002Fstrong\u003E）：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fjuejin.cn\u002Fpost\u002F7190312484492804156\"\u003E想弄懂Babel？你必须得先弄清楚这几个包\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E它主要介绍了我们平时项目中使用\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的几个包，并答疑了我们学习\u003Ccode\u003EBabel\u003C\u002Fcode\u003E时的一些疑惑，让我们对\u003Ccode\u003EBabel\u003C\u002Fcode\u003E有个系统大致的理解。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fjuejin.cn\u002Fpost\u002F7197666704435920957\"\u003EBabel配置不要再“复制粘贴”了，带你自己配一个Babel\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E它主要讲解了我们平时项目中使用\u003Ccode\u003EBabel\u003C\u002Fcode\u003E配置的一些原理，还有应该如何更好的配置。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch1\u003E备注\u003C\u002Fh1\u003E\n\u003Cul\u003E\n\u003Cli\u003E我们把\u003Cstrong\u003E前言\u003C\u002Fstrong\u003E提到的以前的配置方法统称为：旧的配置方法\u003C\u002Fli\u003E\n\u003Cli\u003E我们把这篇文章讲的新的配置方法统称为：新的配置方法\u003C\u002Fli\u003E\n\u003Cli\u003E我们把通过引入\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E的\u003Cstrong\u003E某个模块\u003C\u002Fstrong\u003E（或其他\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E），来实现旧版本浏览器不支持的\u003Cstrong\u003E某个\u003C\u002Fstrong\u003E\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E的过程，叫做垫平\u003C\u002Fli\u003E\n\u003Cli\u003E当前\u003Ccode\u003E@babel\u002Fcore\u003C\u002Fcode\u003E最新版本是：\u003Ccode\u003E7.21.8\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E当前\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E最新版本是：\u003Ccode\u003E7.21.5\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch1\u003E历史问题\u003C\u002Fh1\u003E\n\u003Cp\u003E通过前两篇文章，我们知道：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E我们可以把所有这种存放了\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E的\u003Cstrong\u003E方法与实现的集合\u003C\u002Fstrong\u003E叫做\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E只是一种\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E，还有很多其他\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E。例如： \u003Ca href=\"https:\u002F\u002Flink.juejin.cn\u002F?target=https%3A%2F%2Fgithub.com%2Ftaylorhakes%2Fpromise-polyfill%255B\" title=\"https:\u002F\u002Fgithub.com\u002Ftaylorhakes\u002Fpromise-polyfill%5B\"\u003Epromise-polyfill\u003C\u002Fa\u003E、\u003Ca href=\"https:\u002F\u002Flink.juejin.cn\u002F?target=https%3A%2F%2Fgithub.com%2FGoogleChrome%2Fproxy-polyfill\" title=\"https:\u002F\u002Fgithub.com\u002FGoogleChrome\u002Fproxy-polyfill\"\u003Eproxy-polyfill\u003C\u002Fa\u003E 、\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fes-shims\u002Fes5-shim\"\u003Ees-shims\u003C\u002Fa\u003E等\u003C\u002Fli\u003E\n\u003Cli\u003E如果我们是用\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E这个\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E来垫平的话，应该用\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E的最新版本来垫平，越新的版本，包含的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E实现就越多\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EOK，我们接着往下看。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\"\u003EBabel项目\u003C\u002Fa\u003E中有这样一个包——\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel-polyfills\"\u003Ebabel-polyfills\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E注意：大家看清楚，不是\u003Ccode\u003E@babel\u002Fpolyfill\u003C\u002Fcode\u003E这个包，它跟\u003Ccode\u003E@babel\u002Fpolyfill\u003C\u002Fcode\u003E是两码事\u003Cbr\u003E\n不了解\u003Ccode\u003E@babel\u002Fpolyfill\u003C\u002Fcode\u003E这个包的朋友，之前的文章——\u003Ca href=\"https:\u002F\u002Fjuejin.cn\u002Fpost\u002F7190312484492804156\"\u003E想弄懂Babel？你必须得先弄清楚这几个包\u003C\u002Fa\u003E中有专门的说明\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E它的出现，有一段故事，主要是为了解决以下问题（更详细的故事，可以看看\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel\u002Fissues\u002F10008\"\u003E这里\u003C\u002Fa\u003E）：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E以前\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E这个包的\u003Ccode\u003Etargets\u003C\u002Fcode\u003E选项，不能与\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E这个包共享，\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E设置不了\u003Ccode\u003Etargets\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E上面我们说过，\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E只是一种\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E，还有很多其他\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E。所以有可能不是所有人都想用\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E这个\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E为了更好的用户体验，旧的配置方法太繁琐\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003E补充\u003C\u002Fh2\u003E\n\u003Cp\u003E关于问题一，我们再做一些补充：\u003C\u002Fp\u003E\n\u003Cp\u003E在旧的配置方法中，如果我们想开发一个第三方库的话，我们是利用\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E的配置方法来开发的（因为配置\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E，会以局部方式垫平\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E）但是在以前，这会导致库的体积十分庞大。\u003C\u002Fp\u003E\n\u003Cp\u003E这是因为之前\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E（或者别的插件）不能识别到我们要兼容的目标环境（即\u003Ccode\u003Etargets\u003C\u002Fcode\u003E，或者是\u003Ccode\u003Epackjson\u003C\u002Fcode\u003E的\u003Ccode\u003Ebrowserslist\u003C\u002Fcode\u003E），所以会把我们代码中使用到的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003Cstrong\u003E都垫平\u003C\u002Fstrong\u003E，即使我们目标环境支持这些\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E但是在我们后续学习\u003Ccode\u003EBabel\u003C\u002Fcode\u003E配置的时候，我们会发现\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E（或者别的插件）是可以识别\u003Ccode\u003Etargets\u003C\u002Fcode\u003E的，不能识别\u003Ccode\u003Etargets\u003C\u002Fcode\u003E这个问题并不能很好的体会到。这就让我们十分疑惑。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E如果你在学习\u003Ccode\u003EBabel\u003C\u002Fcode\u003E过程中对这个问题有过疑惑的话，可以去\u003Cstrong\u003E相关答疑模块\u003C\u002Fstrong\u003E查看原因\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch1\u003E结构\u003C\u002Fh1\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel-polyfills\"\u003Ebabel-polyfills\u003C\u002Fa\u003E 可以看作是一个总的资源包，它存放了三种用于垫平\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E的插件包：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel-polyfills\u002Fblob\u002Fmain\u002Fpackages\u002Fbabel-plugin-polyfill-corejs2\"\u003Ebabel-plugin-polyfill-corejs2\u003C\u002Fa\u003E：用\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E \u003Ccode\u003E2+\u003C\u002Fcode\u003E版本来垫平\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel-polyfills\u002Fblob\u002Fmain\u002Fpackages\u002Fbabel-plugin-polyfill-corejs3\"\u003Ebabel-plugin-polyfill-corejs3\u003C\u002Fa\u003E：用\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E \u003Ccode\u003E3+\u003C\u002Fcode\u003E版本来垫平\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel-polyfills\u002Fblob\u002Fmain\u002Fpackages\u002Fbabel-plugin-polyfill-es-shims\"\u003Ebabel-plugin-polyfill-es-shims\u003C\u002Fa\u003E：用\u003Ccode\u003Ees-shims\u003C\u002Fcode\u003E这个\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E来垫平\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E（为了解决上述问题二，不是每人都想用\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E这个\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E来垫平）\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EOK，从上面关于三个包的描述，我们可以清楚的知道它们的作用分别是什么。\u003C\u002Fp\u003E\n\u003Cp\u003E我们重点关注 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel-polyfills\u002Fblob\u002Fmain\u002Fpackages\u002Fbabel-plugin-polyfill-corejs3\"\u003Ebabel-plugin-polyfill-corejs3\u003C\u002Fa\u003E 这个包，因为：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003EBabel\u003C\u002Fcode\u003E推荐的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E是\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E，目前\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E最新版本已经是\u003Ccode\u003E3+\u003C\u002Fcode\u003E的版本了\u003C\u002Fli\u003E\n\u003Cli\u003E我自己也试了一下用\u003Ccode\u003Ees-shims\u003C\u002Fcode\u003E来垫平\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，然而并没有\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E那么方便（大家也可以自己试试）\u003C\u002Fli\u003E\n\u003Cli\u003E通过\u003Ccode\u003Ebabel-plugin-polyfill-corejs3\u003C\u002Fcode\u003E这个包的名字，以此类推，后续如果\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E升级到\u003Ccode\u003E4+\u003C\u002Fcode\u003E版本的话，应该会再出\u003Ccode\u003Ebabel-plugin-polyfill-corejs4\u003C\u002Fcode\u003E这个包等\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Ebabel-plugin-polyfill-corejs3\u003C\u002Fcode\u003E这个包也已经在\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E内部使用了（\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel\u002Fpull\u002F12583\"\u003E相关链接\u003C\u002Fa\u003E）\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E官方所说的新的配置方法，也是基于这个包\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch1\u003E回顾\u003C\u002Fh1\u003E\n\u003Cp\u003E在讲解如何使用新配置方法前，我们先大致回顾分析一下旧的配置方法是怎么配置，方便后续我们更好的理解如何使用。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E在这里只是大概说明，更详细的分析，建议大家去阅读上一篇文章——\u003Ca href=\"https:\u002F\u002Fjuejin.cn\u002Fpost\u002F7197666704435920957\"\u003EBabel配置不要再“复制粘贴”了，带你自己配一个Babel\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E笼统的来说，平时我们做开发，不是开发大型项目、应用程序，就是开发第三方库。\u003Cbr\u003E\n而这些都是需要配置\u003Ccode\u003EBabel\u003C\u002Fcode\u003E来垫平我们不支持\u003Ccode\u003EES6\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E的目标环境的。所以在这里，我们可以笼统的把垫平方式看成两大方式：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E全局方式垫平 —— 适用于大型项目或者应用程序\u003C\u002Fli\u003E\n\u003Cli\u003E局部方式垫平 —— 适用于开发第三方库\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003E全局方式垫平\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Cstrong\u003E全局的方式\u003C\u002Fstrong\u003E垫平\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，则都是利用\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E的配置功能，它有两种配法（配置代码见\u003Cstrong\u003E前言模块\u003C\u002Fstrong\u003E）：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ccode\u003EuseBuiltIns: 'entry'\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EuseBuiltIns: 'usage'\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3\u003E\u003Ccode\u003EuseBuiltIns: 'entry'\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003E这种方式比较简单粗暴。它需要我们在\u003Cstrong\u003E入口\u003C\u002Fstrong\u003E文件手动\u003Ccode\u003Eimport\u003C\u002Fcode\u003E\u003Cstrong\u003E所有\u003C\u002Fstrong\u003E或者\u003Cstrong\u003E某块\u003C\u002Fstrong\u003E\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E，这样\u003Ccode\u003EBabel\u003C\u002Fcode\u003E会引入我们目标环境（\u003Ccode\u003Etargets\u003C\u002Fcode\u003E）不支持的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E模块。\u003C\u002Fp\u003E\n\u003Cp\u003E这种方式可以避免一些奇奇怪怪的问题，但某种程度来说，也会增大我们打包后的体积。\u003C\u002Fp\u003E\n\u003Ch3\u003E\u003Ccode\u003EuseBuiltIns: 'usage'\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Cp\u003E这种方式则不需要我们手动引入\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E。\u003Ccode\u003EBabel\u003C\u002Fcode\u003E会根据我们\u003Cstrong\u003E当前代码中用到的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E，并判断当前的\u003Ccode\u003Etargets\u003C\u002Fcode\u003E支不支持我们用到的这个\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，不支持的话则\u003Cstrong\u003E自动导入这个\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E对应的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E这种方式虽然比较方便，但它是根据我们\u003Cstrong\u003E当前自己代码中\u003C\u002Fstrong\u003E用到的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E来做判断的。所以如果我们使用的第三方库中，有用到我们当前\u003Ccode\u003Etargets\u003C\u002Fcode\u003E不支持的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，但是我们自己的代码又没有用到这个\u003Ccode\u003EAPI\u003C\u002Fcode\u003E的话，那就会出问题了。\u003C\u002Fp\u003E\n\u003Cp\u003E具体问题可以看看这个例子 \u003Ca href=\"https:\u002F\u002Flink.juejin.cn\u002F?target=https%3A%2F%2Fgithub.com%2Flimingcan562%2Flearn-babel-7%2Ftree%2Fmain%2Fknow-babel-config%2Fuse-third-party-library-problem\" title=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fknow-babel-config\u002Fuse-third-party-library-problem\"\u003Euse-third-party-library-problem\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch2\u003E局部方式垫平\u003C\u002Fh2\u003E\n\u003Cp\u003E如果我们开发的是一个第三方库，我们当然要把我们的代码与使用者的代码做隔离，所以我们是需要以局部方式来垫平\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E的。\u003C\u002Fp\u003E\n\u003Cp\u003E而以\u003Cstrong\u003E局部的方式\u003C\u002Fstrong\u003E垫平\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，则是利用\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E的配置功能（配置代码见\u003Cstrong\u003E前言模块\u003C\u002Fstrong\u003E）。\u003C\u002Fp\u003E\n\u003Cp\u003E它会判断我们想要兼容的目标环境（很久以前判断不了），并根据\u003Cstrong\u003E我们代码中使用到的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E，最后再将\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E以\u003Cstrong\u003E局部变量的方式\u003C\u002Fstrong\u003E进行垫平。\u003C\u002Fp\u003E\n\u003Ch1\u003E使用\u003C\u002Fh1\u003E\n\u003Cp\u003E上面我们的大概说了：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E新的配置方法诞生的一些历史\u003C\u002Fli\u003E\n\u003Cli\u003E新的配置方法是基于 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel-polyfills\u002Fblob\u002Fmain\u002Fpackages\u002Fbabel-plugin-polyfill-corejs3\"\u003Ebabel-plugin-polyfill-corejs3\u003C\u002Fa\u003E 这个插件包\u003C\u002Fli\u003E\n\u003Cli\u003E回顾了一下旧的配置方法\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E我们先来看看新的配置方法是怎么配置的，先有个大概印象：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003Econst presets = [\n    '@babel\u002Fpreset-env',\n]\nconst plugins = [\n    [\n        'babel-plugin-polyfill-corejs3',\n        {\n            method: &quot;entry-global&quot;, \u002F\u002F usage-global || usage-pure\n            version: '3.20.2',\n            proposals: true\n        }\n    ],\n    '@babel\u002Fplugin-transform-runtime',\n];\n\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E我们可以跟\u003Cstrong\u003E前言模块\u003C\u002Fstrong\u003E旧的配置方法对比一下，\u003Cstrong\u003E这简直简便的不能再简便\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EOK，接下来我们具体看看到底怎么配置。\u003C\u002Fp\u003E\n\u003Ch2\u003E配置项\u003C\u002Fh2\u003E\n\u003Cp\u003E在提了 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel\u002Fissues\u002F15412#issuecomment-1518201737\"\u003Eissues\u003C\u002Fa\u003E 询问了关于文档的配置项，并得到\u003Ccode\u003EBabel\u003C\u002Fcode\u003E贡献者的\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel\u002Fissues\u002F15412#issuecomment-1518289649\"\u003E回答\u003C\u002Fa\u003E后，可以知道 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel-polyfills\u002Fblob\u002Fmain\u002Fpackages\u002Fbabel-plugin-polyfill-corejs3\"\u003Ebabel-plugin-polyfill-corejs3\u003C\u002Fa\u003E 这个包有以下配置项：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E\u003Ccode\u003Emethod\u003C\u002Fcode\u003E（重点）\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E\u003Ccode\u003Eversion\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E\u003Ccode\u003Eproposals\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E\u003Ccode\u003Etargets\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EignoreBrowserslistConfig\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EconfigPath\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Edebug\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Einclude\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eexclude\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EshouldInjectPolyfill\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EabsoluteImports\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EmissingDependencies\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E大家不要被那么多配置项吓到，\u003Cstrong\u003E平常用到的就前三个\u003C\u002Fstrong\u003E（\u003Ccode\u003Etargets\u003C\u002Fcode\u003E也会讲解一下），其他的在我们需要用到的时候在学（太累了，能不学的尽量不学）。\u003C\u002Fp\u003E\n\u003Ch2\u003E\u003Ccode\u003Emethod\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003E这个配置项就是用来\u003Cstrong\u003E控制我们垫平\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E的方式。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E它一共有三个值：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Eentry-global\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eusage-global\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eusage-pure\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E我们可以这么拆解，这样更方便我们记忆使用：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E我们可以把\u003Ccode\u003E-\u003C\u002Fcode\u003E前面当做第一部分，它指的是控制\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E引入的方式。是手动在\u003Cstrong\u003E入口\u003C\u002Fstrong\u003E引入，还是根据\u003Cstrong\u003E我们代码中用到的\u003C\u002Fstrong\u003E\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E自动引入\u003C\u002Fli\u003E\n\u003Cli\u003E我们可以把\u003Ccode\u003E-\u003C\u002Fcode\u003E前面当做第二部分，它指的是\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E是以\u003Cstrong\u003E全局\u003C\u002Fstrong\u003E还是\u003Cstrong\u003E局部\u003C\u002Fstrong\u003E的方式垫平\u003C\u002Fli\u003E\n\u003Cli\u003E我们也会发现它们的值，跟旧的配置方法有所对应\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3\u003E\u003Ccode\u003Eentry-global\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Ch4\u003E分析\u003C\u002Fh4\u003E\n\u003Cp\u003E我们可以把值拆成两部分来看：\u003Ccode\u003Eentry\u003C\u002Fcode\u003E跟\u003Ccode\u003Eglobal\u003C\u002Fcode\u003E。从这两个十分语义化的词我们可以知道：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Eentry\u003C\u002Fcode\u003E：\u003Cstrong\u003E入口\u003C\u002Fstrong\u003E。它指的是我们要在\u003Cstrong\u003E入口\u003C\u002Fstrong\u003E引入我们的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eglobal\u003C\u002Fcode\u003E：\u003Cstrong\u003E全局\u003C\u002Fstrong\u003E。指的是，\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E以\u003Cstrong\u003E全局的方式\u003C\u002Fstrong\u003E垫平\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E我们以\u003Ccode\u003Eie 11\u003C\u002Fcode\u003E为目标浏览器，用 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fnew-babel-config\u002Fentry-global\"\u003Eentry-global\u003C\u002Fa\u003E 这个例子，来感受一下它跟旧的配置方法有没有什么区别：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp6-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F7773adf26eab41dbbebcf89b4bc2c8ed~tplv-k3u1fbpfcp-watermark.image?\" alt=\"entry-global.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E根据上面的结果，我们会发现：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E使用了新旧两种配置方法，发现编译后，注入的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E都是\u003Cstrong\u003E234行\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E编译后的文件都是一模一样的。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4\u003E总结\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Ccode\u003Emethod: 'entry-global'\u003C\u002Fcode\u003E相当于旧的配置方法中的\u003Ccode\u003EuseBuiltIns: 'entry'\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Ch4\u003E注意\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel-polyfills\u002Ftree\u002Fmain\u002Fpackages\u002Fbabel-plugin-polyfill-corejs3\"\u003E文档\u003C\u002Fa\u003E说\u003Ccode\u003Eversion\u003C\u002Fcode\u003E配置项，只有在使用\u003Ccode\u003Eusage-global\u003C\u002Fcode\u003E或者\u003Ccode\u003Eusage-pure\u003C\u002Fcode\u003E时才有用。\u003C\u002Fp\u003E\n\u003Cp\u003E但是我试了一下，\u003Cstrong\u003E在\u003Ccode\u003Eentry-global\u003C\u002Fcode\u003E也是可以使用\u003Ccode\u003Eversion\u003C\u002Fcode\u003E的\u003C\u002Fstrong\u003E，所以我有提 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel\u002Fissues\u002F15618\"\u003Eissues\u003C\u002Fa\u003E，目前没有答复\u003C\u002Fp\u003E\n\u003Ch3\u003E\u003Ccode\u003Eusage-global\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Ch4\u003E分析\u003C\u002Fh4\u003E\n\u003Cp\u003E我们可以把值拆成两部分来看：\u003Ccode\u003Eentry\u003C\u002Fcode\u003E跟\u003Ccode\u003Eglobal\u003C\u002Fcode\u003E。从这两个十分语义化的词我们可以知道：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Eusage\u003C\u002Fcode\u003E：\u003Cstrong\u003E用法\u003C\u002Fstrong\u003E。它指的是\u003Cstrong\u003E我们代码中用到\u003C\u002Fstrong\u003E的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eglobal\u003C\u002Fcode\u003E：\u003Cstrong\u003E全局\u003C\u002Fstrong\u003E。指的是\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E以\u003Cstrong\u003E全局的方式\u003C\u002Fstrong\u003E垫平\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E我们以\u003Ccode\u003Eie 11\u003C\u002Fcode\u003E为目标浏览器，使用两个\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ftc39\u002Fproposal-array-grouping\"\u003Earray-grouping\u003C\u002Fa\u003E：它是个可以让数组分组更方便的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E，目前它处于\u003Ccode\u003Estage-3\u003C\u002Fcode\u003E阶段\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EPromise\u003C\u002Fcode\u003E：我们最熟悉的异步\u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E并且用 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fnew-babel-config\u002Fusage-global\"\u003Eusage-global\u003C\u002Fa\u003E 这个例子来感受一下它跟旧的配置方法有没有什么区别：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp6-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F75edf2860ee843c7b36c52d10d506ecf~tplv-k3u1fbpfcp-watermark.image?\" alt=\"usage-global.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E根据上面的结果，我们会发现：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E在\u003Ccode\u003Eie 11\u003C\u002Fcode\u003E中，只垫平了我们用到的那两个\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E编译后的文件都是一模一样的\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4\u003E总结\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Ccode\u003Emethod: 'usage-global'\u003C\u002Fcode\u003E相当于旧配置方法中的\u003Ccode\u003EuseBuiltIns: 'usage'\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Ch3\u003E\u003Ccode\u003Eusage-pure\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\n\u003Ch4\u003E分析\u003C\u002Fh4\u003E\n\u003Cp\u003E我们可以把值拆成两部分来看：\u003Ccode\u003Eusage\u003C\u002Fcode\u003E跟\u003Ccode\u003Epure\u003C\u002Fcode\u003E。从这两个十分语义化的词我们可以知道：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Eusage\u003C\u002Fcode\u003E：\u003Cstrong\u003E用法\u003C\u002Fstrong\u003E。它指的是\u003Cstrong\u003E我们代码中用到\u003C\u002Fstrong\u003E的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Epure\u003C\u002Fcode\u003E：\u003Cstrong\u003E纯净\u003C\u002Fstrong\u003E。指的是\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E以\u003Cstrong\u003E局部的方式\u003C\u002Fstrong\u003E垫平，并不会\u003Cstrong\u003E污染\u003C\u002Fstrong\u003E全局，因此它是纯净的\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E我们以\u003Ccode\u003Eie 11\u003C\u002Fcode\u003E为目标浏览器，还是使用上面两个\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ftc39\u002Fproposal-array-grouping\"\u003Earray-grouping\u003C\u002Fa\u003E：它是个可以让数组分组更方便的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E，目前它处于\u003Ccode\u003Estage-3\u003C\u002Fcode\u003E阶段\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EPromise\u003C\u002Fcode\u003E：我们最熟悉的异步\u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E并且用 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fnew-babel-config\u002Fusage-pure\"\u003Eusage-pure\u003C\u002Fa\u003E 这个例子来感受一下它跟旧的配置方法有没有什么区别：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp9-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F820523ab632240799e8a17807f02fe7f~tplv-k3u1fbpfcp-watermark.image?\" alt=\"usage-pure.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E根据上面的结果，我们会发现：\u003C\u002Fp\u003E\n\u003Cp\u003E旧的配置方法，是\u003Cstrong\u003E无法垫平一些提案阶段的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E的\u003C\u002Fstrong\u003E。因为：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E旧的配置设置的\u003Ccode\u003Eversion\u003C\u002Fcode\u003E只能是\u003Ccode\u003E3\u003C\u002Fcode\u003E，\u003Ccode\u003E3\u003C\u002Fcode\u003E代表的是\u003Ccode\u003Ecore-js@3.0.0\u003C\u002Fcode\u003E的版本，那它肯定不能垫平一些比较新的提案\u003C\u002Fli\u003E\n\u003Cli\u003E新的配置方法，是可设置\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E的次版本号的（\u003Ccode\u003Ecore-js@3.x.x\u003C\u002Fcode\u003E），因此它能支持更多的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E。所以新的配置方法更加强大\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4\u003E总结\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Emethod: 'usage-pure'\u003C\u002Fcode\u003E相当于旧配置方法中，配置\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E的方式\u003C\u002Fli\u003E\n\u003Cli\u003E新的配置方法比旧的配置方法\u003Cstrong\u003E更简便，更强\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4\u003E注意\u003C\u002Fh4\u003E\n\u003Cp\u003E我们需要\u003Ccode\u003Enpm i core-js-pure -S\u003C\u002Fcode\u003E，因为：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E以\u003Cstrong\u003E全局变量方式\u003C\u002Fstrong\u003E垫平是基于\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E这个包\u003C\u002Fli\u003E\n\u003Cli\u003E以\u003Cstrong\u003E局部变量方式\u003C\u002Fstrong\u003E垫平是基于\u003Ccode\u003Ecore-js-pure\u003C\u002Fcode\u003E这个包\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E文档没有说，不安装相关依赖的话，会报错\u003C\u002Fp\u003E\n\u003Ch2\u003E\u003Ccode\u003Etargets\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003E它指的是我们垫平\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E的\u003Cstrong\u003E目标环境\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E这个配置项设计的初衷是为了解决\u003Cstrong\u003E历史问题模块\u003C\u002Fstrong\u003E提到的第一个问题：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E利用\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E配置开发第三方库时，以前\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E是不能识别\u003Ccode\u003Etargets\u003C\u002Fcode\u003E的，这会导致库的体积很大。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E所以有了\u003Ccode\u003Etargets\u003C\u002Fcode\u003E这个配置项，会帮我们大大的减少体积。\u003C\u002Fp\u003E\n\u003Cp\u003E我们进行以下步骤：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E安装\u003Ccode\u003E&lt; 7.13.0\u003C\u002Fcode\u003E版本的\u003Ccode\u003EBabel\u003C\u002Fcode\u003E（\u003Ccode\u003E@babel\u002Fcore@7.12.0\u003C\u002Fcode\u003E）\u003C\u002Fli\u003E\n\u003Cli\u003E使用\u003Ccode\u003EPromise\u003C\u002Fcode\u003E、\u003Ccode\u003EArray.includes\u003C\u002Fcode\u003E两个\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E然后用 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fnew-babel-config\u002Ftarget-configuration\"\u003Etarget-configuration\u003C\u002Fa\u003E 这个案例，感受一下以前\u003Ccode\u003Etargets\u003C\u002Fcode\u003E这个配置项在以前是怎么发挥作用的。\u003C\u002Fp\u003E\n\u003Cp\u003E我们先看第一个结果（不配置\u003Ccode\u003Etargets\u003C\u002Fcode\u003E，但设置了\u003Ccode\u003Ebrowserslist: [&quot;chrome 100&quot;]\u003C\u002Fcode\u003E）：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F3fd0e2684fae438ba2a164cb44e22ee2~tplv-k3u1fbpfcp-watermark.image?\" alt=\"targets-problem-1.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E按照最新版本的\u003Ccode\u003EBabel\u003C\u002Fcode\u003E来说，设置了\u003Ccode\u003Ebrowserslist: [&quot;chrome 100&quot;]\u003C\u002Fcode\u003E，我们的代码只会垫平\u003Ccode\u003Echrome 100\u003C\u002Fcode\u003E不支持的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E。\u003Cbr\u003E\n但是现在我们安装的是比较旧的版本（\u003Ccode\u003E7.12.0\u003C\u002Fcode\u003E），根据上图我们会发现，即使我们设置的目标浏览器（\u003Ccode\u003Echrome 100\u003C\u002Fcode\u003E）是支持这些\u003Ccode\u003EAPI\u003C\u002Fcode\u003E的，但\u003Ccode\u003EBabel\u003C\u002Fcode\u003E依旧垫平了这些\u003Ccode\u003EAPI\u003C\u002Fcode\u003E，所以我们的库会变得十分大，这是\u003Cstrong\u003E历史问题模块\u003C\u002Fstrong\u003E问题一很好的体现。\u003C\u002Fp\u003E\n\u003Cp\u003E我们再来看第二个结果（配置\u003Ccode\u003Etargets\u003C\u002Fcode\u003E）:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002F6ac88338abc94378975abfa758afa2af~tplv-k3u1fbpfcp-watermark.image?\" alt=\"targets-problem-2.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E我们会发现，因为我们新的配置方法设置了\u003Ccode\u003Etargets\u003C\u002Fcode\u003E，所以此时\u003Ccode\u003EBabel\u003C\u002Fcode\u003E不会垫平\u003Ccode\u003Etargets\u003C\u002Fcode\u003E支持的\u003Ccode\u003EAPI\u003C\u002Fcode\u003E，这大大节约了我们库的体积。这就很好的解决了\u003Cstrong\u003E历史问题模块\u003C\u002Fstrong\u003E的问题一。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E在\u003Ccode\u003EBabel &gt;= 7.13.0\u003C\u002Fcode\u003E的版本以后，在\u003Ccode\u003EBabel\u003C\u002Fcode\u003E配置文件新增了一个顶级的\u003Ccode\u003Etargets\u003C\u002Fcode\u003E，并且\u003Ccode\u003EBabel\u003C\u002Fcode\u003E也支持识别\u003Ccode\u003Ebrowserslist\u003C\u002Fcode\u003E\u003Cbr\u003E\n所以在新的配置方法里\u003Ccode\u003Etargets\u003C\u002Fcode\u003E这个配置项就不怎么用了。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2\u003E\u003Ccode\u003Eversion\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003E它指的是我们提供\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E的集合包（像\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E，里面存放了很多\u003Ccode\u003Epolyfll\u003C\u002Fcode\u003E集合）的版本。\u003C\u002Fp\u003E\n\u003Cp\u003E因为我们是使用\u003Ccode\u003Ebabel-plugin-polyfill-corejs3\u003C\u002Fcode\u003E这个包\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E全局方式垫平的话，是用\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E这个包来垫平，所以\u003Ccode\u003Eversion\u003C\u002Fcode\u003E指的是\u003Ccode\u003Ecore-js\u003C\u002Fcode\u003E版本\u003C\u002Fli\u003E\n\u003Cli\u003E局部方式垫平的话，是用\u003Ccode\u003Ecore-js-pure\u003C\u002Fcode\u003E这个包来垫平的，所以\u003Ccode\u003Eversion\u003C\u002Fcode\u003E指的就是\u003Ccode\u003Ecore-js-pure\u003C\u002Fcode\u003E的版本\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E我们\u003Ccode\u003Eversion\u003C\u002Fcode\u003E当然是要越高越好，这样包含的\u003Ccode\u003Epolyfill\u003C\u002Fcode\u003E才会更多\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E参考文章：\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel-polyfills\u002Ftree\u002Fmain\u002Fpackages\u002Fbabel-plugin-polyfill-corejs3\"\u003Ebabel-plugin-polyfill-corejs3\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch2\u003E\u003Ccode\u003Eproposals\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Cp\u003E它指的是，我们是否开启编译处于提案阶段的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，那我们当然是要开启的，这个值只有在\u003Ccode\u003Emethod: 'usage-global'\u003C\u002Fcode\u003E 或者 \u003Ccode\u003Emethod: 'usage-pure'\u003C\u002Fcode\u003E时有用\u003C\u002Fp\u003E\n\u003Ch1\u003E相关答疑\u003C\u002Fh1\u003E\n\u003Cp\u003E在\u003Cstrong\u003E历史问题\u003C\u002Fstrong\u003E模块中，我们有说到：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E在后续学习的过程中，我们发现\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E（或者别的插件）是可以识别\u003Ccode\u003Etargets\u003C\u002Fcode\u003E的，\u003Cstrong\u003E但有些文章说不能识别\u003C\u002Fstrong\u003E，这加深了我们对\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的疑惑。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E其实这一切的原因还是因为：\u003Cstrong\u003E我们后续学习\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的时候，\u003Ccode\u003EBabel\u003C\u002Fcode\u003E已经进行了很多更新，我们当前学习\u003Ccode\u003EBabel\u003C\u002Fcode\u003E时候的版本，跟以前那会的\u003Ccode\u003EBabel\u003C\u002Fcode\u003E版本已经不一样了，因此问题不能很好的体现。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E所以以后我们学习\u003Ccode\u003EBabel\u003C\u002Fcode\u003E一定要注意好版本号，这就是为什么关于\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的文章，我都会写上\u003Ccode\u003EBabel\u003C\u002Fcode\u003E版本备注的原因。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EOK，我们接着往下看。\u003C\u002Fp\u003E\n\u003Cp\u003E在\u003Ccode\u003EBabel\u003C\u002Fcode\u003E发布\u003Ccode\u003E7.13.0\u003C\u002Fcode\u003E版本时候有一些\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fblog\u002F2021\u002F02\u002F22\u002F7.13.0\"\u003E记录\u003C\u002Fa\u003E说到：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E增加了顶层的\u003Ccode\u003Etargets\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E支持识别\u003Ccode\u003Ebrowserslist\u003C\u002Fcode\u003E里面环境\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E这就是为什么后续我们学习\u003Ccode\u003EBabel\u003C\u002Fcode\u003E，有些文章说\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E不能识别\u003Ccode\u003Etargets\u003C\u002Fcode\u003E，但是我们照着例子敲，结果却是可以识别的原因。\u003Cstrong\u003E因为我们学习的时候，\u003Ccode\u003EBabel\u003C\u002Fcode\u003E版本可能已经\u003Ccode\u003E&gt;= 7.13.0\u003C\u002Fcode\u003E，并且可能配置了\u003Ccode\u003Ebrowserslist\u003C\u002Fcode\u003E或者\u003Ccode\u003Etargets\u003C\u002Fcode\u003E，这时\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E已经可以识别\u003Ccode\u003Etargets\u003C\u002Fcode\u003E了\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E为了更好的感受这个问题，我们用 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fnew-babel-config\u002Ftransform-runtime-targets-problem\"\u003Etransform-runtime-targets-problem\u003C\u002Fa\u003E 这个案例来感受一下：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E我们安装一个\u003Ccode\u003E&lt; 7.13.0\u003C\u002Fcode\u003E版本（\u003Ccode\u003E7.12.0\u003C\u002Fcode\u003E）\u003C\u002Fli\u003E\n\u003Cli\u003E配置\u003Ccode\u003Ebrowerslist\u003C\u002Fcode\u003E为\u003Ccode\u003Echrome 100\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E使用\u003Ccode\u003EArray\u003C\u002Fcode\u003E的\u003Ccode\u003Eincludes\u003C\u002Fcode\u003E方法（\u003Ccode\u003Echrome 100\u003C\u002Fcode\u003E已经支持）\u003C\u002Fli\u003E\n\u003Cli\u003E使用\u003Ccode\u003EPromise\u003C\u002Fcode\u003E（\u003Ccode\u003Echrome 100\u003C\u002Fcode\u003E已经支持）\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E我们来看看结果：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp6-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fee0e2a906e2a433dad3deac6dfcb807a~tplv-k3u1fbpfcp-watermark.image?\" alt=\"transform-runtime-targets-problem.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Echrome 100\u003C\u002Fcode\u003E已经支持了\u003Ccode\u003EArray\u003C\u002Fcode\u003E的\u003Ccode\u003Eincludes\u003C\u002Fcode\u003E跟\u003Ccode\u003EPromise\u003C\u002Fcode\u003E，但依旧被垫平了。\u003C\u002Fp\u003E\n\u003Cp\u003E因为我们安装的\u003Ccode\u003EBabel &lt; 7.13.0\u003C\u002Fcode\u003E，此时还没实现插件能识别\u003Ccode\u003Etargets\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E根据这个案例，相信大家应该对\u003Ccode\u003EBabel\u003C\u002Fcode\u003E的疑惑又减少了一些了。\u003C\u002Fp\u003E\n\u003Ch1\u003E新配置方法目前存在的问题\u003C\u002Fh1\u003E\n\u003Cp\u003E我们在\u003Cstrong\u003E回顾模块\u003C\u002Fstrong\u003E有说到，使用局部变量的方式垫平\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，它会根据\u003Cstrong\u003E我们代码中使用到的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E，最后再以\u003Cstrong\u003E局部变量的方式\u003C\u002Fstrong\u003E进行垫平。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003EBabel\u003C\u002Fcode\u003E在进行编译的时候，是会注入很多\u003Cstrong\u003E辅助函数\u003C\u002Fstrong\u003E的，那么会有这样一种情况：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E我们的代码中没有使用到\u003Ccode\u003EPromise\u003C\u002Fcode\u003E，但是辅助函数中用到了\u003Ccode\u003EPromise\u003C\u002Fcode\u003E，那这时我们的代码是不会垫平\u003Ccode\u003EPromise\u003C\u002Fcode\u003E的，因为我们自己的代码中没有用到\u003Ccode\u003EPromise\u003C\u002Fcode\u003E，那这是不是会导致代码报错呢？\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E这是个很现实的问题，我们用 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\u002Ftree\u002Fmain\u002Fnew-babel-config\u002Fusage-pure-problem\"\u003Eusage-pure-problem\u003C\u002Fa\u003E  这个例子来看看新旧配置方法，对于这块问题有没有处理。\u003C\u002Fp\u003E\n\u003Ch2\u003E旧的配置方法\u003C\u002Fh2\u003E\n\u003Cp\u003E我们先看看旧的配置方法的表现：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp6-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fd8296e0a02c543bdb28b4a2d963c6976~tplv-k3u1fbpfcp-watermark.image?\" alt=\"usage-pure-problem-1.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E我们来分析一下这个编译过程：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E我们的源码里面只使用了\u003Ccode\u003Easync\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EBabel\u003C\u002Fcode\u003E从\u003Ccode\u003E@babel\u002Fruntime-corejs3\u003C\u002Fcode\u003E这个包里引入了辅助函数\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eie 11\u003C\u002Fcode\u003E正常运行\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003E新的配置方法\u003C\u002Fh2\u003E\n\u003Cp\u003E我们先看看新的配置方法的表现：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp3-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fc9daf0390d91468e84e2e68527031905~tplv-k3u1fbpfcp-watermark.image?\" alt=\"usage-pure-problem-2.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E我们来分析一下这个编译过程：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E我们的源码里面只使用了\u003Ccode\u003Easync\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003EBabel\u003C\u002Fcode\u003E从\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E这个包里引入了辅助函数\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eie 11\u003C\u002Fcode\u003E报错\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003E分析\u003C\u002Fh2\u003E\n\u003Cp\u003E我们来分析一下，为什么新的配置方法在\u003Ccode\u003Eie 11\u003C\u002Fcode\u003E会报\u003Ccode\u003EPromise\u003C\u002Fcode\u003E的错。\u003C\u002Fp\u003E\n\u003Cp\u003E我们自己的源码中没有用到\u003Ccode\u003EPromise\u003C\u002Fcode\u003E，所以这个\u003Ccode\u003EPromise\u003C\u002Fcode\u003E肯定来自辅助函数。我们可以看到新旧配置方法，引入的辅助函数是来自不同的包：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E旧的配置方法辅助函数来自：\u003Ccode\u003E@babel\u002Fruntime-corejs3\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E新的配置方法辅助函数来自：\u003Ccode\u003E@babel\u002Fruntime\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E经过一番查询，我们发现：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E旧的配置方法，\u003Ccode\u003EPromise\u003C\u002Fcode\u003E来自辅助函数的这个包：\u003Ccode\u003E@babel\u002Fruntime-corejs3\u002Fhelpers\u002FasyncToGenerator\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E新的配置方法，\u003Ccode\u003EPromise\u003C\u002Fcode\u003E来自辅助函数的这个包：\u003Ccode\u003E@babel\u002Fruntime\u002Fhelpers\u002FasyncToGenerator\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E我们对比一下这两个包有什么不一样的：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fp6-juejin.byteimg.com\u002Ftos-cn-i-k3u1fbpfcp\u002Fb2a0660e874943fca2eb1dcf6c2bc798~tplv-k3u1fbpfcp-watermark.image?\" alt=\"usage-pure-problem-3.png\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E通过分析对比，我们可以很清楚的知道：\u003C\u002Fp\u003E\n\u003Cp\u003E旧的配置方法，引入的辅助函数都是局部变量方式的存在的，所以我们不需要担心我们辅助函数里的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E没有被垫平；而新的配置方法则不是。\u003C\u002Fp\u003E\n\u003Ch2\u003E总结\u003C\u002Fh2\u003E\n\u003Cp\u003E所以，按目前情况来说，如果我们想\u003Cstrong\u003E开发第三方库\u003C\u002Fstrong\u003E，并且想用新的配置方法来代替旧的配置方法：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E我们要注意，这可能会导致在旧的浏览器运行不起来的情况。因为在新的配置方法中，辅助函数可能存在\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，它不会被垫平。\u003C\u002Fli\u003E\n\u003Cli\u003E新的配置方法目前来说，适用于我们要兼容的一些比较新的目标环境\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E以上问题当然也有别的开发者发现了，目前这个问题已经解决了，估计后续的版本会修复。在修复以后，开发第三方库，我们就可以完完全全的用新的配置方法代替旧的配置方法了。\u003C\u002Fp\u003E\n\u003Cp\u003E参考文章：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel\u002Fissues\u002F15572\"\u003E@babel\u002Fplugin-transform-runtime not transform Object.hasOwn correctly\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel-polyfills\u002Fissues\u002F128\"\u003EownKeys, _objectSpread not imported from @babel\u002Fruntime helpers\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel\u002Fpull\u002F15426\"\u003EAdd back moduleName option to @babel\u002Fplugin-transform-runtime\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbabel\u002Fbabel\u002Fpull\u002F15531\"\u003EAllow polyfill providers to specify custom @babel\u002Fruntime pkg\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch1\u003E总结\u003C\u002Fh1\u003E\n\u003Cp\u003EOK，最后我们总结一下新的配置方法：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003E如果我们开发的项目是\u003Cstrong\u003E应用程序\u003C\u002Fstrong\u003E，或者\u003Cstrong\u003E大型的项目\u003C\u002Fstrong\u003E，那我们可以这么配置：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u002F\u002F Babel配置\nconst presets = [\n    [\n        '@babel\u002Fpreset-env',\n        { modules: false }\n    ]\n];\nconst plugins = [\n    '@babel\u002Fplugin-transform-runtime',\n    [\n        'babel-plugin-polyfill-corejs3',\n        {\n            method: &quot;entry-global&quot;, \u002F\u002F 或者method: &quot;usage-global&quot;\n            version: '3.20.2',\n            proposals: true\n        }\n    ]\n];\nmodule.exports = {plugins, presets};\n\n\u002F\u002F package.json\n{\n    ...,\n    \u002F\u002F 设置目标环境\n    &quot;browserslist&quot;: [\n        &quot;ie 11&quot;\n    ]\n}\n\n\u002F\u002F 入口文件\n\u002F\u002F ---- useBuiltIns: 'entry'时，需要引入以下----\n\u002F\u002F 垫平全部ES6+稳定版API\nimport 'core-js\u002Fstable'; \n\u002F\u002F ---- 或者 -----\n\u002F\u002F 垫平所有ES6+ API，包括提案阶段\nimport 'core-js';\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003E如果我们是想开发一个\u003Cstrong\u003E第三方库\u003C\u002Fstrong\u003E，我们可以这么配置：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u002F\u002F Babel配置\nconst presets = [\n    [\n        '@babel\u002Fpreset-env',\n        { modules: false }\n    ]\n];\nconst plugins = [\n    '@babel\u002Fplugin-transform-runtime',\n    [\n        'babel-plugin-polyfill-corejs3',\n        {\n            method: &quot;usage-pure&quot;,\n            version: '3.20.2',\n            proposals: true\n        }\n    ]\n];\nmodule.exports = {plugins, presets};\n\n\u002F\u002F package.json\n{\n    ...,\n    \u002F\u002F 设置目标环境\n    &quot;browserslist&quot;: [\n        &quot;ie 11&quot;\n    ]\n}\n\n\u002F\u002F 入口文件\nconst Method = {\n    wait(delay) {\n        return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(), delay);\n    }\n}\n...\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E我们可以对比一下旧的配置方法，新的配置方法更加的简洁，更加的强大。我们相当于:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E利用\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E进行\u003Ccode\u003EES6+\u003C\u002Fcode\u003E语法编译\u003C\u002Fli\u003E\n\u003Cli\u003E利用\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E来优化辅助函数的引入，从而减少体积\u003C\u002Fli\u003E\n\u003Cli\u003E利用\u003Ccode\u003Ebabel-plugin-polyfill-corejs3\u003C\u002Fcode\u003E来垫平\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E我们根本不需要在\u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E跟\u003Ccode\u003E@babel\u002Fplugin-transform-runtime\u003C\u002Fcode\u003E这两个包切来切去；我们只需要关注\u003Ccode\u003Ebabel-plugin-polyfill-corejs3\u003C\u002Fcode\u003E如何配置就可以了\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E各个插件都做到了很好的功能配置区分，更条理了\u003C\u002Fp\u003E\n\u003Cp\u003E另外：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E如果想用新的配置方法用来\u003Cstrong\u003E开发第三方库\u003C\u002Fstrong\u003E，需要注意一些旧版本的浏览器可能会报错，因为它不会垫平辅助函数里面的\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E。所以想开发第三方库，\u003Cstrong\u003E新的配置方法更适合用于一些比较新的浏览器\u003C\u002Fstrong\u003E（后续这个问题会修复，就可以完全替代）\u003C\u002Fli\u003E\n\u003Cli\u003E如果想用新的配置方法用来\u003Cstrong\u003E开发应用项目或大型项目\u003C\u002Fstrong\u003E，用全局方式垫平\u003Ccode\u003EES6+\u003C\u002Fcode\u003E \u003Ccode\u003EAPI\u003C\u002Fcode\u003E，那么\u003Cstrong\u003E新的配置方法完全可以直接代替旧的配置方法\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch1\u003E最后\u003C\u002Fh1\u003E\n\u003Cp\u003E文章涉及到的例子，已经上传 \u003Ca href=\"https:\u002F\u002Flink.juejin.cn\u002F?target=https%3A%2F%2Fgithub.com%2Flimingcan562%2Flearn-babel-7\" title=\"https:\u002F\u002Fgithub.com\u002Flimingcan562\u002Flearn-babel-7\"\u003EGithub\u003C\u002Fa\u003E，觉得有帮助的话，欢迎\u003Ccode\u003EStar\u003C\u002Fcode\u003E或者\u003Ccode\u003EFork\u003C\u002Fcode\u003E学习（写文章真的很辛苦）。\u003C\u002Fp\u003E\n\u003Cp\u003E如果读完这篇文章的你，觉得真的有帮助到，\u003Cstrong\u003E欢迎点赞收藏\u003C\u002Fstrong\u003E；如果有异同点，\u003Cstrong\u003E欢迎在评论区讨论\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n"}}],fetch:{},mutations:[]});